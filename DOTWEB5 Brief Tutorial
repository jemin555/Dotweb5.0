
üåü DOTWEB5.0 Tutorial


‚ú® UNIT‚Äë1 : Introduction to DOTWEB5.0(OJ7) Programming Language


üìò Definition

DOTWEB5.0 is a programming language designed for code security and console-based software development. It is advanced, learnable, and applicable in various domains such as software development, remote applications (Remote X), web applications, and machine learning. It is symbolized by a star icon and works with frameworks like the Scroll Framework.

üßë‚Äçüíª About DOTWEB5.0

DOTWEB5.0 was invented by Wilmix Jemin J in 2013, evolving from Java and DOTWEB3.0. Earlier versions of Java (JDK 1.7 and JDK 1.8) were vulnerable to source code extraction using tools like JAD decompiler. This inspired the creation of DOTWEB5.0 to enhance security and prevent easy reverse engineering. 

Special thanks to Venkat, GitHub, and other supporters for their contributions.

‚ö†Ô∏è Limitations of Java and C#

Java class files are easily decompiled using JAD, making software vulnerable.

DOTWEB5.0 addresses this by translating .java7 files into secure DOTWEB5.0 class files, which are not easily understood by hackers.

It is not intended for GUI development (e.g., Java Swing).

üõ†Ô∏è Can You Build a Compiler Like Java?

Yes. Using Java, you can build compilers for Java or other languages. While some may criticize this approach, it aligns with compiler design principles. The same applies to languages like C. However, the focus of DOTWEB5.0 is not on GUI frameworks like Java Swing or J2EE, due to concerns about misinformation and competitive sabotage.

üß™ Compiler Design History

At age 21, Wilmix Jemin J designed a compiler in VC++.

Later, he developed a mini compiler in Java.

üöÄ Why Is DOTWEB5.0 More Advanced?

It uses fluent, English-like syntax similar to Java/J2EE.

It reduces lines of code significantly.

It supports camel case and integrates well with IDEs like IntelliJ.

The author opposes robot development due to ethical concerns but supports AI.

The OakJava8 module excels in mobile computing.

üì¶ DOTWEB5.0 Modules

DOTWEB5.0 is divided into two modules:

Module 1

Module 2

Module Overview

DOTWEB5.0 keywords resemble Java, making it easy for Java professionals to adopt. It supports console applications, web development, machine learning, data science, and Remote X applications. Module 1 is primarily used by Java and DOTWEB5.0 professionals. Remote X will be released after the completion of machine learning and data science modules.

üîë Reserved Keywords in DOTWEB5.0 (Module 1)

These keywords cannot be used as variable names, method names, class names, or other identifiers.


abstract


assert


boolean


break


byte


case


char


continue


default


do

while

double


else


enum


<---


final




float


for


if


-->




instanceof


int


interface


long


native


new




private


protected


public


return


short






switch


synchronized




throw


throws


transient




void


volatile


while


üß™ Sample Program: testme.java7


testme.java7


<JAVA7>


public <CLASS> testme 

//--> Runnable

<--- <Thread>


<%





public <SHARED> int sum()


{


int b;



return(2+3);

}

     public synchronized void <RUN>


{


<TRY>

{

<PRINTLINE>(" Under Weight is less than  15 your health is  worst ="+sum());


<Thread>.sleep(1000); 

throw new Exception();

}


<CATCH> (Exception e)

{

<PRINTLINE>(""+e);



}



}



 <MAIN>


          <%

<TRY>


{



testme t <NEW> testme();


t.start();



testme t1 <NEW> testme();


t1.start();

                 int value = 15;

if (value >=15)

{

        assert value >= 25 : " Underweight";

      <PRINTLINE>(" value is " + value);


}

else

{

 <PRINTLINE>(" Under Weight is less than  15");

}



}


<CATCH> (Exception e)

{


<PRINTLINE>(""+e);


}


<FINALLY> 


{


<PRINTLINE>("   note: please enter accurately");



}


         %>


</JAVA7>


üñ•Ô∏è Output

Value is 15 

Underweight is less than 15. 

Your health is poor = 5

 Underweight is less than 15. 

Your health is poor = 5

 Note: Please enter accurately

 java.lang.Exception 

java.lang.Exception


üíé DotWeb5.0 Reserved Keywords ‚Äì Module 2

DotWeb5.0 defines a set of reserved keywords that cannot be used as variable names, method names, class names, or other identifiers. In Module 2, we focus on developing prototype software (e.g., .exe files) for console-based DotWeb5.0 applications. This module is designed to be accessible for professionals familiar with DotWeb5.0, Java, and J2EE.

üîë Reserved Keywords Overview

DotWeb5.0 includes 50 reserved keywords. Below is a summary of their purpose:


<ABSTRACT> 

-> Abstract class can be created using <ABSTRACT> keyword. 


<BREAK> -> Break out of loop


<CASE>  -> Case keyword is used as option with Switch statement.


<CATCH> => It is used to catch Exceptions.


<CLASS> -> Class is the collection of objects


<CONTINUE> -> Continue with in a loop


<DO> --- <WHILE> -> <DO> keyword  is used with While loop. While  will continue executes statements in the block

until the condition in while is  true.

<ELSE>  -> <ELSE> key word  is  followed after <IF> statement


<ENUM> => 


An enum is a special "class" that represents a group of constants (unchangeable/read-only variables).



<FINALLY> => The Keyword <FINALLY> is used in finally block. It did not mind whether there is catch block present or not. It will  always execute...



<FOR> => This keyword is used for  Forloop.


<FOREACH> => 


The foreach loop is used to iterate over the elements of the collection.

 The collection may be an array or a list or  set. 

It executes for each element present in the array.


<GOTO> goto => <GOTO> keyword is  used with labels.


<IF> => <IF> keyword is for condition purpose


is =>  The is keyword operator is used to check if the run-time type of an object is compatible with the given type or not. 

It returns true if the given object is of the same type otherwise, return false. It also returns false for null objects. 


<IN> => It is  used for the given element is  present or not.


<OBJECT> => object are the  instance of the class  that 

are created to use the attributes and methods of a class.

<INTERFACE> =>  Interface is used multiple inheritance

<DEFAULT>   => Default Keyword is used with the switch statement.

<BASE> => base keyword, we can call the base class method also. It is useful if base and derived classes defines same method. 

In other words, if method is overridden.

<LOCK> => 

Lock keyword ensures that one thread is executing a piece of code at one time. The lock keyword ensures that one thread does not enter a critical section of code   while another thread is in that critical section.

<PACK> => <PACK> keyword means PACKAGE in DotWeb5.0.

A package is a namespace that organizes a set of related classes and interfaces.

<NEW>  => It is used to create a object of the class.

<OPERATOR> => It is used for Operator loading.

<READONLY> =>

The readonly keyword can be used to define a variable or an object as readable only.

 This means that the variable or object can be assigned a value at the class scope

 or in a constructor only. You cannot change the value or reassign a value to a readonly variable

 or object in any other method except the constructor.

<RET> -> Return the Value of any type


<SIZEOF> => The sizeof operator returns the number of bytes occupied by a variable of a given type.

<TYPEOF> => It is used to get a Type object representing String.

void => Void type means we  can  call the method in the main program section.It have no return type. 

Shared => If a class is static and it contains any  userdefined methods. That can be  called in main class

without creating a Object. eg) student is the static class which contains display method.Then

how it  can be  called , that can be  achieved using student.display().


<STR>  => <STR> keyowrd is String in DotWeb5.0

<STRUCT> => This  keyword represents structure of records.

<SWITCH> => switch keyword is  used  to select one of many code blocks to be executed.

<IS> => <IS> keyword represent this


<TRY> => This represent try block

<THROW> => This is used to throw the  exception 

<USE> => This is  used to  call any DotWeb5.0 libraries or DotWeb5.0 packages and  we can reuse it.

<VIRTUAL> =>

 virtual method is a method that can be overridden in a derived class. When a method is declared as 

virtual in a base class, it allows a derived class to provide its own implementation of the method.

<VOLATILE> => This keyword represent synchronization happen at variable. All threads can access the 

Volatile variable.

<WHILE> => This keyword represent  while loop

<JAVA7>  => This keyword is used to load io packages.Which will b  used  with Java/J2ee professionals.

<JAVA>  => This keyword is used to load io packages, used to create  a prototype console and  web application ,etc.

<HEAPJ7> => HeapJ7 keyword respresent we  can store any objects contains millions of  data by using the J7heap. It is  used to avoid Memmory overflow...

<CONVERTARRAYLIST> ,J7mem.ConverttoArrayList => This ConverttoArrayList method is  used to convert string to arraylist.

<OVERRIDE> => This keyword is  used to override the  method of parent  class.

bool => This keyword will be  used to  hold the true or  false value.The bool indicates boolean in DotWeb5.0. eg) bool a =true; bool b=false;

get and  set  => get keyword is used for retrieving data. And set is  used for setting value.


<OAKJAVA7SECURITY> => This  is use to maintain security for  DotWeb5.0 executable file.


=========================================================================================================

üí† Diamond Modules

DotWeb5.0 Module-1 and Module-2 are collectively referred to as the Diamond Module, supporting .java7 programs. When compiled using the DOTWEB5.0 compiler, a .java7 file produces both .jclass and .exe outputs. DOTWEB5.0 is open-source and available for DotWeb5.0 professionals.

A third module focused on security is available in the DotWeb5.0 Enterprise Edition.


‚öôÔ∏è DotWeb5.0 Structure

What Is a Structure?

A structure is a value-type data construct that allows a single variable to hold related data of various types.

Syntax

AccessModifier StructureName {

 // Structure block contains: 

// Fields, Parameterized constructors, Constants, Properties, 

// Various data types, and Methods 

}


üìò Example: Copying Structure Data


Goal: Create a structure named Person with fields Name, Age, and Weight. Assign values and copy data from one structure to another.

Filename: j7samplestructure.java7

// DotWeb5.0 program to illustrate structure copying StructApplication 

<JAVA>

// DotWeb5.0 program to illustrate copy the structure

<PACK> StructApplication {


// Defining structure

public <STRUCT> Person

{

	// Declaring different data types

	public string Name;

	public int Age;

	public int Weight;


}


<CLASS> JITs {

	

	// Main Method

	public void main() 

	{


		// Declare P1 of type Person

		Person P1;


		// P1's data

		P1.Name = "Wilmix Jemin";

		P1.Age = 21;

		P1.Weight = 58;

		

		// Declare P2 of type Person

		Person P2;

		

		// Copying the values of P1 into P2

		P2 = P1;


		// Displaying the values of P1

		<PRINTLN>("Values Stored in P1");

		<PRINTLN>("Name: " +P1.Name);

		<PRINTLN>("Age: " +P1.Age);

		<PRINTLN>("Weight: " +P1.Weight);

		<PRINTLN>("");

		

		// Displaying the values of P2

		<PRINTLN>("Values Stored in P2");

		<PRINTLN>("Name: " +P2.Name);

		<PRINTLN>("Age: " +P2.Age);

		<PRINTLN>("Weight: " +P2.Weight);

							

	}

}

}


üñ•Ô∏è Output


Values Stored in P1

Name: Wilmix Jemin

Age: 21

Weight: 58


Values Stored in P2

Name: Wilmix Jemin

Age: 21

Weight: 58



‚ú® Operator Overloading in DotWeb 5.0

üìò What Is Operator Overloading?

In DotWeb 5.0, operator overloading allows developers to redefine the behavior of standard operators (like +, -, *, /) for user-defined types. This is achieved using a special method called an operator function.

üîß Key Characteristics of Operator Functions

Must be declared as public static

Use the keyword operator followed by the operator symbol

Accept one argument for unary operators and two for binary operators

üßæ Syntax


public static return-type operator op (argument list)

op is the operator to be overloaded

operator is a required keyword


üß™ Example Program: Operator Overloading in DotWeb 5.0

This example demonstrates how to overload binary operators (, , , ) for a custom  class.

üìÑ File: Calculator.java


<JAVA>


<PACK> calcpackage {

	

<CLASS> Calculator {

	

	public int number = 0;

	

	// no-argument constructor

	public Calculator() {}

	

	

	// parameterized constructor

	public Calculator(int n)

	{

		number = n;

	}

	

	// Overloading of Binary "+" operator

	public Shared Calculator <OPERATOR>+ (Calculator Calc1,Calculator Calc2)

	{

		Calculator Calc3 <NEW> Calculator(0);

		Calc3.number = Calc2.number + Calc1.number;

		return Calc3;

	}


        // Overloading of Binary "-" operator

	public Shared Calculator <OPERATOR>- (Calculator Calc1,Calculator Calc2)

	{

		Calculator Calc3 <NEW> Calculator(0);

		Calc3.number = Calc2.number - Calc1.number;

		return Calc3;

	}

	


// Overloading of Binary "*" operator

	public Shared Calculator <OPERATOR>* (Calculator Calc1,Calculator Calc2)

	{

		Calculator Calc3 <NEW> Calculator(0);

		Calc3.number = Calc2.number * Calc1.number;

		return Calc3;

	}


// Overloading of Binary "/" operator

	public Shared Calculator <OPERATOR>/ (Calculator Calc1,Calculator Calc2)

	{

		Calculator Calc3 <NEW> Calculator(0);

		Calc3.number = Calc1.number / Calc2.number;

		return Calc3;

	}



	// function to display result

	public void Print()

	{

		<PRINTLN>("{0}", number);

	}

}



<CLASS> CalNum {

	

	// Driver Code

     public void main()

	{

		

		Calculator num1 <NEW> Calculator(500);

		Calculator num2 <NEW> Calculator(80);

		Calculator num3 <NEW> Calculator();

		

	 <PRINTLN>("------------------------------------");	

		num3 = num1 + num2;

		

		num1.Print(); // Displays 500

		

		num2.Print(); // Displays 80

		

		num3.Print(); // Displays 580

 <PRINTLN>("------------------------------------");

              num3 = num1 - num2;


               num3.Print();

              <PRINTLN>("------------------------------------");

                num3 = num1 * num2;


               num3.Print();

 <PRINTLN>("------------------------------------");

                  num3 = num1 / num2;


               num3.Print();


		

	}

}

}



üñ•Ô∏è Output

------------------------------------ 

500

80 

580 

------------------------------------ 

420 

------------------------------------ 

40000 

------------------------------------ 6




üåê DotWeb5.0 Error Documentation

üìò Module 1: Basic Error Handling

Module 1 is straightforward. Whenever an error occurs, it is automatically logged in the out.txt file located in the directory where the oakjava7 files reside.
There is no need for in-depth study‚Äîjust practice, and you‚Äôll grasp it quickly.

üìò Module 2: Error Code Reference

This document provides detailed explanations for each DotWeb5.0 error code.
For example, when compiling a program using Webc7 .java7 or .web extension, an error such as int c = 100 / 0; will trigger a message box displaying:

Line No: [X] Error Code: J70020 ‚Üí Division by constant zero

Similar error models exist for other types of errors.

üß™ Running DotWeb5.0 in JShell (Instead of Command Prompt)

Follow these steps to run DotWeb5.0 using JShell:

Launch JShell

Double-click the Jshell.bat file in your folder.

In this example, .java7 files are stored in the wilmix7 directory.

Alternatively, create a .bat file that runs Java7Shell.exe and includes the path C:/oakjava7/src.

Compile and Run

Navigate to your working directory (e.g., C:/wilmix7).

Use JShell to compile .java7 files. DotWeb5.0 will compile and execute them, producing .class and .jclass files.

These files are used for rendering scrollable web pages (web applications).

For best results, compile .java7 files using the Visual Studio Command Prompt.


‚ö†Ô∏è Error Codes and Their Explanations




üìò Unit 2: Program Structures in DotWeb5.0

DotWeb5.0 introduces a unique programming model that differs from traditional Java. Below are the key syntax structures and examples to help you understand and implement DotWeb5.0 programs effectively.

üß© SYNTAX 1: Basic DotWeb5.0 Program Structure

Filename: Filename.java7

public class <classname> { 

// Mandatory constructor with super() call

 public <classname> () 

{ super(); } 

// Main method for DotWeb5.0 logic

 public void main()

 { } 

}

‚úÖ Example: Query3.java7

class Query3 

{ public Query3() 

{ super(); } 

// Method to display HTML content 

public void displayHtmlToWeb(String a){ 

print("\n\n"); print("Welcome!" + a); print("\n\n"); 

} 

// DotWeb5.0 main method (not static) 

public void main() 

{ 

displayHtmlToWeb(" to Everybody");

 }

 }

üîç Note: This structure resembles Java Servlets and is available only in the Enterprise Edition. The compiled class file is sealed as: "DotWeb5.0 (JAVA7.0) Compiler - Jemin Information Technology - JIT-777-WRIT-0003 Query3.class" This type of program is referred to as a DotWeb5.0 Servlet.


üß© SYNTAX 2: Package-Based Structure

Filename: Filename.java7

<JAVA>

<USE> packages;

<PACK> packagename

{

    <CLASS>  <classname>

   {

      public void main()

      {

        <! source  code !>

      }

   }

}


üß© SYNTAX 3: JAVA7-Based Structure

Filename: Filename.java7

<JAVA7>

<Access modifiers>  <CLASS> <classname>

{

 <MAIN> //  it  means it cannot  be  run   in   jdk1.8 compiler

<%

<!  OAKJAVA7 Logic  !>

%>

</JAVA7>


üß± DotWeb5.0 Program Structure Breakdown


JAVA7.0  SYNTAX-1  Program  Structure(.java7)

Declaration DotWeb5.0  Section  : 


 public class  <classname>

{

//This constructor with super method is mandatory, which indicates it is a DotWeb5.0 

//program and  class name and   constructor name should be  same

public  <classname>() 

{ 

super();

}

Documentation  Section 

// it means it will not support any java compiler, it is entirely different.

Package  Statement;

Import  Statement;

DotWeb5.0 LOGIC  SECTION

// DotWeb5.0  main method should have public void main  method  otherwise DotWeb5.0

program  will not  compile....

   public void main()

{

<! DotWeb5.0 Logic !>

}

CLOSE DotWeb5.0  LOGIC  SECTION   }

LOGIC  DotWeb5.0  DATASTRUCTURE SECTION

class  <CLASSNAME>

{


private <CLASSNAME>()

	{

		super();

	}

................

................

................


CLOSE LOGIC DotWeb5.0 DATASTRUCTURE SECTION }


ENDING  SECTION : 


üîç Explanation

All  DotWeb5.0   should    start    DotWeb5.0  declaration section as


public class  <classname>

{

//This constructor with super method is mandatory, which indicates it is a DotWeb5.0 program.

The class name and  constructor  of  DotWeb5.0 program should be  same.


public  <classname>() 

{ 

super();

}   

after that DotWeb5.0 LOGIC  SECTION should be

   public void main()

{

<! DotWeb5.0 Logic !>

}

so <!DotWeb5.0 Logic>  may have print statements, for loop,

Datastructure statements belong to  another class.

But Logic  DotWeb5.0  DataStructure Section should be in this format

class  <CLASSNAME>

{


private <CLASSNAME>()

	{

		super();

	}

and Close Logic DotWeb5.0 DataStructure section by using   curly braces which is "}".

I hope  this  syntax  change  will be  easy  to  follow  and  to  do programming  

in DotWeb5.0. I remove the  complexity of  the  DotWeb5.0  program syntax. So now

this  type  of  DotWeb5.0 servlet  syntax  is  learnable.


SYNTAX 2: Enterprise Edition Format

Filename: Filename.java7

DotWeb5.0  SYNTAX-2 Program Structure

Beginning  Section  :  <JAVA>

Documentation  Section 

Package  Statement;

<USE> Statement;

<PACK> packagename

LOGIC  SECTION

    <CLASS>  <classname>

   {

      public void main()

      {

        <! source  code !>

      }

CLOSE  LOGIC  SECTION

ENDING  SECTION : }


üîç Explanation

DotWeb5.0  Ending  section  is   }  ;  Ending  your  DotWeb5.0  program

Documentation  Section   means   you  can  include  description   

with  comments.

Package  statement  means   you   had  to  include  DotWeb5.0 program  in  Package  ....

<USE>  statement  to  import  all  the  packages.

Interface   statement   for    supporting   multiple  inheritance.

Logic   section    for   writing   DotWeb5.0  logic  with   Class   followed  by main   method .

after  writing logic   close    the  logic   section.


üßæ SYNTAX 3: JAVA7 Format

Filename: Filename.java7

Beginning  Section  :  <JAVA7>

Documentation  Section 

Package  Statement;

Import  Statement;

LOGIC  SECTION

<Access modifiers>  <CLASS> <classname>

   {

     <MAIN>

      {

        <! source  code !>

      }

CLOSE  LOGIC  SECTION

ENDING  SECTION : </JAVA7>


üîç Explanation

All  DotWeb5.0   should   start   with   <JAVA7> then after  that  followed  by <CLASS>  <classname>   

But   <MAIN>  is   used   instead   for  

 public  static void  main(String args[]) for  protection  from hackers.

Logic   section    for   writing   DotWeb5.0  logic  with   Class   followed  by main   method .

after  writing logic   close    the  logic   section. 

 


üî¢ Example: Print Numbers from 0 to 99

Filename: display2.java7

<JAVA7>

public <CLASS>  display2

{

<MAIN>

<%

for (int i=0;i<100;i++)

{

<PRINTLINE>(""+i);

}

%>

</JAVA7>


üñ®Ô∏è Output

0 1 2 ... 99




üìò DotWeb5.0 Major Program (Java7 Collections Example)


Programs1.java7


<JAVA>

<USE> <WEB7>.IO; //<WEB7>-io packages

<USE> CUTIL; //Web7 cutil packages

<PACK> BoxApplication

{

   <CLASS> Box

   {

      private double length;   // Length of a box

      private double breadth;  // Breadth of a box

      private double height;   // Height of a box


      public void setLength( double len )

      <%

         length = len;

      }


      public void setBreadth( double bre )

      <%

         breadth = bre;

      }


      public void setHeight( double hei )

      <%

         height = hei;

      }


      public double getVolume()

      <%

         return length * breadth * height;

      }

   }


   <CLASS> Boxtester

   {

      public void main()

      {

         Box Box1 <NEW> Box();   // Declare Box1 of type Box

         Box Box2 <NEW> Box();

         double volume;


         // Declare Box2 of type Box

         // box 1 specification

         Box1.setLength(6.0);

         Box1.setBreadth(7.0);

         Box1.setHeight(5.0);


         // box 2 specification

         Box2.setLength(12.0);

         Box2.setBreadth(13.0);

         Box2.setHeight(10.0);


         // volume of box 1

         volume = Box1.getVolume();

         <PRINTLN>("Volume of Box1 :" +volume);


         // volume of box 2

         volume = Box2.getVolume();

         // <PRINTLN>("Volume of Box2 : {0}", volume);


         // Console.ReadKey();

         CUTIL.ArrayList x <NEW> CUTIL.ArrayList();


         // test size

         <PRINTLN>("Initial size is " + x.size());


         // test isEmpty

         if (x.isEmpty())

            <PRINTLN>("The list is empty");

         else <PRINTLN>("The list is not empty");


         // test put into  ArrayList

         x.add(0, Java7Collection.QUERY()); // get previous data  from java7collection and put it into java7-arraylist at 0 location.

         x.add(1, (6));

         x.add(0, (1));

         x.add(2, (4));

         <PRINTLN>("List size is " + x.size());


         // test toString

         <PRINTLN>("The list is " + x);

         String JAVA5 = "Java 5";

         String JAVA6 = "Java 6";

         String JAVA7 = "Java 7";

         int  c=1;

         switch (c) {

             case 1:

                 <PRINTLN>(JAVA5);

                 break;

             case 2:

                 <PRINTLN>(JAVA6);

                 break;

             case 3:

                 <PRINTLN>(JAVA7);

                 break;

         }

         <TRY>

         {

            Java7Collection.InsertQUERY(x.ToString());// insert  arraylist  at  java7 collection memory

            Java7Collection.QUERY(x.ToString(),"display23");// merge  the  output  display23.java7.exe output  with  arraylist

         }

         <CATCH> (<EXE> e) {}


         // test indexOf

         int index = x.indexOf((4));

         if (index < 0)

            <PRINTLN>("4 not found");

         else <PRINTLN>("The index of 4 is " + index);


         index = x.indexOf((3));

         if (index < 0)

            <PRINTLN>("3 not found");

         else <PRINTLN>("The index of 3 is " + index);


         // test get

         <PRINTLN>("Element at 0 is " + x.get(0));

         <PRINTLN>("Element at 3 is " + x.get(3));


         // test remove

         <PRINTLN>(x.remove(1) + " removed"); //arraylist data removed

         <PRINTLN>("The list is " + x);

         <PRINTLN>(x.remove(2) + " removed");// 6  is removed

         <PRINTLN>("The list is " + x);


         if (x.isEmpty())

            <PRINTLN>("The list is empty");

         else <PRINTLN>("The list is not empty");


         <PRINTLN>("List size is " + x.size());

      }

   }

}


‚ú® Explanation 

Used Standard OakJava7(OJ7) syntax.

Organized code into Box and BoxTester classes.

Used ArrayList properly with add, remove, indexOf, and get methods

Used OakJava7 Collection for merging two output values

Here we have used OakJava7 collection to insert arraylist at java7 collection memory. The statement 

for this is given below....

           Java7Collection.InsertQUERY(x.ToString());


Here we have used OakJava7 collection to merge the output  display23.java7.exe output  with  arraylist.The statement for this is  given below....

            Java7Collection.QUERY(x.ToString(),"display23");

This is one of  Advanced  concept  in  OakJava7(JAVA7.0).

The  given  output  indicates that  it  is merging  two DotWeb5.0 output  by using Java7collection.


üñ®Ô∏è Output


Volume of Box1 :210

Initial size is 0

The list is empty

List size is 4

The list is [1, [[1, [[1, [[1, [[1, [[1, [[1, [[1, [[1, [[1, [[1, [[1, [[1, [[1, [[1, [[1, [[1, [[1, [[1, [[1, [[1, [[1, [[1, [2000], 4, 6]], 4, 6]], 4, 6]], 4, 6]], 4, 6]], 4, 6]], 4, 6]], 4, 6]], 4, 6]], 4, 6]], 4, 6]], 4, 6]], 4, 6]], 4, 6]], 4, 6]], 4, 6]], 4, 6]], 4, 6]], 4, 6]], 4, 6]], 4, 6]], 4, 6]], 4, 6]], 4, 6]], 4, 6] 

Java 5

HELLO WORLD!  MY First DotWeb5.0 Program-display-program-1

The index of 4 is 2

3 not found

Element at 0 is 1

Element at 3 is 6

[[1, [[1, [[1, [[1, [[1, [[1, [[1, [[1, [[1, [[1, [[1, [[1, [[1, [[1, [[1, [[1, [[1, [[1, [[1, [[1, [[1, [[1, [[1, [2000], 4, 6]], 4, 6]], 4, 6]], 4, 6]], 4, 6]], 4, 6]], 4, 6]], 4, 6]], 4, 6]], 4, 6]], 4, 6]], 4, 6]], 4, 6]], 4, 6]], 4, 6]], 4, 6]], 4, 6]], 4, 6]], 4, 6]], 4, 6]], 4, 6]], 4, 6]], 4, 6]] removed

The list is [1, 4, 6]

6 removed

The list is [1, 4]

The list is not empty

List size is 2


‚ú® UNIT‚Äë3 : DotWeb5.0 Advanced Concepts


(DotWeb5.0 util packages)

üìñ Introduction

DotWeb5.0 Advanced Concepts were invented by Wilmix Jemin J.


They are part of the DotWeb5.0 Programming Language, with file extension .web7.


ü™£ Bucket

Purpose: Store key‚Äìvalue data and generate random numbers.
Supports datatypes such as string, object, etc.

Syntax:

Bucket list = Bucket(); list.KeyAdd(); list.add(); list.RandomAdd(); list.Display(list);

Advantages:

Retrieve values by position

Fast searching and insertion compared to other DTS

Random indexing supported (duplicate values get unique random keys)

Can store many values

üîó Extend

Purpose: Provides multiple inheritance in (up to 100,000,000 classes).
Behaves like a Bucket but contains a list of classes.

Syntax:

EXTEND <> list11 = EXTEND <> (STRING); list.KeyAdd(); list.add(); list.RandomAdd(); list.Display(list);

Advantages:

Add many values

Indexing supported

Lists class and object values

Stateless

üö¶ Pipe

Purpose: Maintains stateful behavior and supports data flow between classes.
Can add constructor values from multiple classes and display them.

Syntax:

Pipe <> list11 = Pipe <> (STRING); list.KeyAdd(); list.add(); list.RandomAdd(); list.Display(list);

üëú Bag

Extension of: LinkedHashMap
Performance: Faster than Dictionary

Syntax:

Bag object = new Bag(); object.put(key,value);

Functions:

getValues(key) ‚Üí Get values for a key

get(key,loc) ‚Üí Get value at index

containsValue(value) ‚Üí Check if value exists

put(key,value) ‚Üí Add key‚Äìvalue pair

remove(key,value) ‚Üí Remove key‚Äìvalue pair

üå≥ TreeList

Similar to Bucket but stores items in tree format.

Syntax:

TreeList list = new TreeList("BUCKETS"); list.KeyAdd(KEY); list.add(VALUE1); list.RandomAdd(RANDOMNO); list.DisplayO(list,0);

üé≠ Mask

Extension of tree structure, supports left/right retrieval.

Syntax:

Mask m = new Mask(); m.add(multiple values); m.getR(loc); // right position m.getL(loc); // left position

üèî Heap

Creates a balanced tree, inserts data, and displays via inorder traversal.

Syntax:

Heap hob = new Heap(); hob.add(datum); hob = new Heap(key,value1,value2);

ü™£ Bucktist

Similar to Bucket but stores two values per key.

Syntax:

Bucktist l = new Bucktist(key,value1,value2);

üèè Wicket

Stores multiple values with four values per key.

Syntax:

Wicket list12 = new Wicket(key,v1,v2,v3,v4); list12.Display(); list12.Display(list12,location);


üíª Example Programs

Example 1: Bag

<WEB7>

<PACK> MyP

<%

    <CLASS> Programs

    {

        public void main()

        {

        Bag  b <NEW> Bag();

        b.PUT(1,34);

        b.PUT(2,444);

        <PRINTLN>(""+b);

        }

    }

%>

?>

Example 2: CDOLLARARRAYS

<WEB7>

<USE> CUTIL;

<PACK> MyP

{

    <CLASS> Programs

    {

        public void main()

        {

ArrayList ar <NEW> ArrayList ();

for (int i=0;i<=100;i++)

    ar.add(i,i);


<CDOLLARARRAYS> list1 <NEW>  <CDOLLARARRAYS>("ANIMALS ");

list1.add("1 horse");

list1.add("2 pig");

list1.add("3 cow");

list1.add("4 goat");

list1.add("5 chicken");

list1.add("6 ostrich");

list1.add(ar.StringConvert());


for (int i=0;i<list1.size();i++)

    <PRINTLN>(""+list1.get(i));

        }

    }

?>


Example 3: Bootloader

<WEB7>

<USE> CUTIL;

<PACK>  MYOS

{

    <CLASS> MYOs

    {

        public void main(){

            <PRINTLN>("HelloWorld  for  booting  MYOS");

        }

    }

?>

Example 4: Pointers

<WEB7>

<USE> CUTIL;

<PACK> MyP

{

    <CLASS> Programs

    {

        public void main()

        {

            <Str>  s="dsdds";

            {*} l Pointers (s);

            l.add(s);


            for (int i = 0; i NOT= l.size(); i = i + 1)

            {

                <OBJECT> obj=l.GETKEY(i);

                <PRINTLN>(obj);

            }

        }

    }

?>

Example 5: Dictionary

<WEB7>

<PACK> MyP

{

    <CLASS> Programs

    {

        public void main()

        {

            Dictionary<string, string> openWith  <NEW>  Dictionary<string, string>();

            openWith.Add("txt", "notepad.exe");

            openWith.Add("bmp", "paint.exe");

            openWith.Add("dib", "paint.exe");

            openWith.Add("rtf", "wordpad.exe");

        }

    }

?>

Example 6: Extend

<WEB7>

<USE> CUTIL;

<IMPORT>

<PACK> MyP

<%

    <CLASS> Programs

    <%

        public void main()

        {

            EXTEND list <NEW> EXTEND("BUCKETS");

            list.KeyAdd("1101");

            list.add("jemin");

            list.RandomAdd();

            list.Display(list);

            <PRINTLN>(""+list.DisplayO(list,1));

        }

    %>

?>

Example 7: Heap

<WEB7>

<USE> CUTIL;

<PACK> MyP

{

    <CLASS> Programs

    {

        public void main()

        {

            Heap root <NEW> Heap("wilmix");

            for (int i=0;i<=10;i=i+1)

                root.add("item " + i);


            <PRINTLN>(root.size());

            root.printTree();

        }

    }

}

?>


Example 8: LArray

<WEB7>

<USE> CUTIL;

<PACK> MyP

{

    <CLASS> Programs

    {

        public void main()

        {

            LArray root <NEW> LArray("root");

            ArrayList ar <NEW> ArrayList();

            for (int i=0;i<=1000;i++)

                ar.add(i,i);


            root.add("wilmix");

            root.add("jemin");

            root.add("shalom");

            root.add("1010");

            root.add("101");

            root.add("201");

            root.add(ar.StringConvert());

            root.add("100000000");


            root.printTree();

        }

    }

}

?>

Example 9: Pipe

<WEB7>

<USE> CUTIL;

<PACK> MyP

{

    <CLASS> Programs

    {

        public void main()

        {

            Pipe list <NEW> Pipe("BUCKETS");

            list.KeyAdd("1101");

            list.add("jemin");

            list.RandomAdd();

            list.Display(list);

            <PRINTLN>(""+list.DisplayO(list,1));

        }

    }

}

?>

Example 10: TreeList

<WEB7>

<USE> CUTIL;

<PACK> MyP

{

    <CLASS> Programs

    {

        public void main()

        {

            TreeList list <NEW> TreeList("BUCKETS");

            list.KeyAdd("1101");

            list.add("jemin");

            list.RandomAdd("1111");


            TreeList list2 <NEW> TreeList("BUCKETS");

            list2.KeyAdd("1102");

            list2.add("rahul");

            list2.RandomAdd("1112");


            <PRINTLN>("DATA="+list.DisplayO(list,0));

            <PRINTLN>("DATA="+list2.DisplayO(list2,0));

        }

    }

}

?>

üîπ Example‚Äë11 : MASK

Purpose: Demonstrates the use of the MASK structure to add values and print a tree.

<WEB7>

<USE> CUTIL;

<PACK> My

{

    <CLASS> Programs

    {

        public void main()

        {

            MASK root <NEW> MASK("wilmix");

            for (int i = 0; i NOT= 10; i = i + 1)

            {

                root.add("item " + i);

            }


            root <NEW> MASK("root1",1211211,54441);

            root <NEW> MASK("root2",121121,5444);

            root <NEW> MASK("root5",99121888,"5");

            root <NEW> MASK("root3",12112,544);

            root <NEW> MASK("root4",1211,54);

            root <NEW> MASK("root51",121,5);


            root.printTree();

        }

    }

%>

?>

üîπ Example‚Äë12 : WICKET

Purpose: Shows how to store multiple values per key using Wicket.

<WEB7>

<USE> CUTIL;

<PACK> MyPo

{

    <CLASS> Programs

    {

        public void main()

        {

            Wicket list12;


            list12 <NEW> Wicket(1000,10002,43433,4343,5555451);

            list12 <NEW> Wicket(10001,100021,434331,4343,5555452);

            list12 <NEW> Wicket(10002,100022,434332,4343,5555453);

            list12 <NEW> Wicket(10003,100023,434333,4343,5555454);

            list12 <NEW> Wicket(10004,100024,434334,4343,5555455);

            list12 <NEW> Wicket(10005,100025,434335,4343,5555456);


            list12.Display(list12);

            <PRINTLN>("DATA="+list12.DisplayO(list12,0));

        }

    }

%>

?>

üîπ Example‚Äë13 : STRUCTURE

Purpose: Demonstrates pointers and the STRUCTURE keyword to retrieve and display values.

<WEB7>

<USE> CUTIL;

<PACK> MyPoi

{

    <CLASS> Programs

    {

        public void main()

        {

            <Str> s="dsdds";

            {*} l Pointers(s);

            l.add(s);


            for (int i = 0; i NOT= l.size(); i = i + 1)

            {

                <OBJECT> obj=l.GETKEY(i);

                <PRINTLN>(obj);

            }


            <STRUCTURE> list <NEW> <STRUCTURE>(l.GETKEY(0));

            for (int i11 = 0; i11 NOT= list.size(); i11 = i11 + 1)

            {

                <OBJECT> el=list.ret(i11);

                <PRINTLN>("SNO= "+el);

            }

        }

    }

%>

?>

üîπ Example‚Äë14 : BUCKETIST

Purpose: Illustrates the Bucketist structure, which allows storing two values per key.

<WEB7>

<USE> CUTIL;

<PACK> MyP

{

    <CLASS> Programs

    {

        public void main()

        {

            Bucketist bp <NEW> Bucketist("wilmix");

            bp <NEW> Bucketist(1,222,434);

            bp <NEW> Bucketist(1,222,434);


            bp.Display(bp);

            <PRINTLN>("DATA="+bp.DisplayO(bp,1));

        }

    }

%>

?>


üåü Final Notes

DotWeb5.0 Advanced Concepts extend the language with powerful data structures.


üåü UNIT‚Äë4 : DotWeb5.0 Advanced OOPS

üìñ Introduction

DotWeb5.0 Advanced OOPS extends the language with powerful features such as:

Operator Overloading

Friend Functions

JDk‚ÄëJava OOPS

DotWeb5.0 OOPS

 However, many Java developers are not aware of the advanced concepts introduced in DotWeb5.0.

üìÇ DotWeb5.0 FILEAPIs

DotWeb5.0 provides a rich set of File APIs for handling input/output operations:

JFile.display(String f1) ‚Üí Displays file attributes

JFileInputStream.ReadBytes(String f1, int p) ‚Üí Reads bytes from a file

JFileOutputStream.Write(String data, String f1, String f2, String f3, int r1, int r2) ‚Üí Writes data bytes to a file

JFileReader.Read(String f1, int d) ‚Üí Reads data from a file

JFileWriter.Write(String f1, char data[], String f2, String f3, String app, int r1, int r2) ‚Üí Writes character data to a file

JInputStreamReader.ReadLN() ‚Üí Reads a character from a file

JPrinter.call() ‚Üí Enables printer functionality

JPrintWriter.display(String s1) ‚Üí Writes a string

JSerialization.Serialize(String a, String s1, String s2) ‚Üí Serializes and deserializes a string

JStreamTokenizer.Split(String f1) ‚Üí Splits a string into tokens


üíª Program‚Äë1 : oakweb1.java7


<JAVA7>

<CLASS> oakweb1

<%

 void  display() 

<%

<PRINTLINE>("wilmix is going");

%>

%>


<CLASS> oakweb2


<%


 <MAIN> 


//  it  means it cannot  be  run   in   jdk1.8 compiler


<%


oakweb1 o  <NEW>  oakweb1();


<PRINTLINE>("Wilmix is going");


%>


</JAVA7>



// Note: This program cannot be run in JDK 1.8 compiler 

‚öôÔ∏è Compilation & Execution

To compile and run the program, use:

CoreJavac7 oakjava1.java7

üñ•Ô∏è Output

Wilmix is going

==============================================================================================================

üåü UNIT‚Äë5 : DotWeb5.0 Programming Exercises

üåê Dotweb5.0 Programming Exercises
Welcome to the Dotweb5.0 (OJ7) practice set. 


1Ô∏è‚É£ Hello World Program
üìò Description: Print "HelloWorld" in the console.

üíª Code

// Basic Program for HelloWorld

<WEB>

<PACK> example

{

    <CLASS> example1

    {

        public void main()

        {

            string input = Console.ReadLine();

            <J7PRINT>(input);

        }

    }

}


üéØ Input / Output

Input

HelloWorld


Output

HelloWorld


2Ô∏è‚É£ Age Category Program
üìò Description: Use if‚Äìelse to check age and display category.

üíª Code

<WEB>

<PACK> example

{

    <CLASS> example1

    {

        public void main()

        {

            <J7PRINT>("Enter your name :");

            string name = Console.ReadLine();

            <PRINTLN>("");


            <J7PRINT>("Enter your Age :");

            int age = int.Parse(Console.ReadLine());

            <PRINTLN>("");


            if ((age >= 0) && (age <= 9))

                <PRINTLN>("Child is babby");

            else if ((age >= 10) && (age <= 19))

                <PRINTLN>("Child is boy");

            else if ((age >= 20) && (age <= 29))

                <PRINTLN>("Young Boy");

            else if ((age >= 30) && (age <= 39))

                <PRINTLN>("Man");

            else if ((age >= 40) && (age <= 59))

                <PRINTLN>("Medium Man");

            else if (age >= 60)

                <PRINTLN>("Old Man");

        }

    }

}


üéØ Input / Output

Input

Enter your name : Daniel

Enter your Age : 62


Output

Old Man



3Ô∏è‚É£ Positive or Negative Number
üìò Description: Check whether a number is positive or negative.

üíª Code

// Check if the given number is positive or negative

<WEB>

<PACK> testno

{

    <CLASS> testno

    {

        public void main()

        {

            <J7PRINT>("Enter the Number :");

            int no = int.Parse(Console.ReadLine());

            <PRINTLN>("");


            if (no < 0)

                <PRINTLN>("The given number is Negative");

            else if (no >= 0)

                <PRINTLN>("The given number is Positive");

        }

    }

}


üéØ Input / Output

Input

Enter the Number : -1


Output

The given number is Negative



‚ú® Practice Exercises (with Solutions)
a) Factorial Program
üíª Code

<WEB>

<PACK> mathpack

{

    <CLASS> factorial

    {

        public void main()

        {

            <J7PRINT>("Enter the Number :");

            int n = int.Parse(Console.ReadLine());

            int fact = 1;


            for (int i = 1; i <= n; i++)

            {

                fact = fact * i;

            }


            <PRINTLN>("Factorial of " + n + " is : " + fact);

        }

    }

}


üéØ Input / Output

Input

Enter the Number : 5


Output

Factorial of 5 is : 120



b) String with Number
üíª Code

<WEB>

<PACK> stringpack

{

    <CLASS> stringnum

    {

        public void main()

        {

            string text = "Weldone";

            int number = 1345;


            <PRINTLN>(text + " " + number);

        }

    }

}


üéØ Output

Weldone 1345

c) Odd or Even Program
üíª Code

<WEB>

<PACK> numberpack

{

    <CLASS> oddeven

    {

        public void main()

        {

            <J7PRINT>("Enter the Number :");

            int no = int.Parse(Console.ReadLine());

            if (no % 2 == 0)

                <PRINTLN>("The given number is EVEN");

            else

                <PRINTLN>("The given number is ODD");

        }

    }

}


üéØ Input / Output

Input

Enter the Number : 7

Output

The given number is ODD


============================================================================================

üåê Dotweb5.0 Control Structure Examples
üîÑ For Loop ‚Äì Prime Number Check
Program (Dotweb5.0 style):

<WEB>

<PACK> testprime

{

    <CLASS> prime

    {

        public void main()

        {

            <J7PRINT>("Enter the Number :");

            int num = int.Parse(Console.ReadLine());


            bool isPrime = true;


            for (int i = 2; i <= num / 2; i++) {

                if (num % i == 0) {

                    isPrime = false;

                    break;

                }

            }


            if (isPrime && num > 1) {

                <PRINTLN>(num + " is a Prime Number");

            } else {

                <PRINTLN>(num + " is NOT a Prime Number");

            }

        }

    }

}


Sample Output:

Enter the Number : 7

7 is a Prime Number


Enter the Number : 10

10 is NOT a Prime Number


üåà For-Each Loop ‚Äì Rainbow Colours
Program:

<WEB>

<PACK> rainbowcolors

{

    <CLASS> vibgyor

    {

        public void main()

        {

            string [] colours = {"Red","Orange","Yellow","Green","Blue","Indigo","Violet"};


            foreach (string colour in colours) {

                <PRINTLN>("Colour: " + colour);

            }

        }

    }

}


Sample Output:

Colour: Red

Colour: Orange

Colour: Yellow

Colour: Green

Colour: Blue

Colour: Indigo

Colour: Violet



‚ôæÔ∏è While Loop ‚Äì Simple Counter
Program:

<WEB>

<PACK> example

{

    <CLASS> Counter

    {

        public void main()

        {

            int count = 1;


            while (count <= 5) {

                <PRINTLN>("Count is: " + count);

                count++;

            }

        }

    }

}


Sample Output:

Count is: 1

Count is: 2

Count is: 3

Count is: 4

Count is: 5



üßë‚Äçüíª Switch Case ‚Äì Employee Roles by EmpCode
Program:

<WEB>

<PACK> employees

{

    <CLASS> empcodes

    {

        public void main()

        {

            <J7PRINT>("Enter the Employee code :");

            int empcode = int.Parse(Console.ReadLine());


            switch (empcode) {

                case 1:

                    <PRINTLN>("Junior Software Engineer");

                    break;

                case 2:

                    <PRINTLN>("Senior Software Engineer");

                    break;

                case 3:

                    <PRINTLN>("Developer Lead");

                    break;

                case 4:

                    <PRINTLN>("Tech Lead");

                    break;

                case 5:

                    <PRINTLN>("Team Lead");

                    break;

                case 6:

                    <PRINTLN>("Software Architect");

                    break;

                case 7:

                    <PRINTLN>("Project Manager");

                    break;

                default:

                    <PRINTLN>("Invalid Employee Code");

                       break;

            }

        }

    }

}


Sample Output:

Enter the Employee code : 3

Developer Lead


Enter the Employee code : 8

Invalid Employee Code



‚ú® Summary:


These examples demonstrate the four main control structures in Dotweb5.0:

For Loop ‚Üí Prime number check

For-Each Loop ‚Üí Rainbow colours

While Loop ‚Üí Counter

Switch Case ‚Üí Employee role lookup

================================================================================================

üßë‚Äçüíª Dotweb5.0 Structures Type-1


## üìå what is  Dotweb5.0 Structure ?


- Structures are declared using the **`struct`** keyword.  

- They are similar to classes but are **stored on the stack** (value type).  

- A structure can include:  

  - **Fields**  

  - **Methods**  

  - **Properties**  

  - **Constructors**  

- Unlike classes, **structs cannot inherit** from another struct or class. However, they **can implement interfaces**.  

- Best suited for **small data structures** that represent simple values such as coordinates, colors, or records.  


## üñ•Ô∏è Example: DotWeb5.0 Structure


Webstructures.web


<WEB>

<PACK> geometry

{

    <STRUCT> Point

    {

        public int X;

        public int Y;


        // Constructor

        public Point(int x, int y)

        {

            X = x;

            Y = y;

        }


        // Method: distance from origin

        public double DistanceFromOrigin()

        {

            return Math.Sqrt((X * X) + (Y * Y));

        }


        // Static method: add two points

        public Shared Point Add(Point a, Point b)

        {

            Point result <NEW> Point(0,0);

            result.X = a.X + b.X;

            result.Y = a.Y + b.Y;

            return result;

        }


        public void Print()

        {

            <PRINTLN>("(" + X + "," + Y + ")");

        }

    }


    <STRUCT> Rectangle

    {

        public Point TopLeft;

        public int Width;

        public int Height;


        public Rectangle(Point topLeft, int width, int height)

        {

            TopLeft = topLeft;

            Width = width;

            Height = height;

        }


        public int Area()

        {

            return Width * Height;

        }


        public bool Contains(Point p)

        {

            return (p.X >= TopLeft.X) &&

                   (p.Y >= TopLeft.Y) &&

                   (p.X <= TopLeft.X + Width) &&

                   (p.Y <= TopLeft.Y + Height);

        }


        public void Print()

        {

            <PRINTLN>("Rect @ (" + TopLeft.X + "," + TopLeft.Y +

                      ") w=" + Width + " h=" + Height);

        }

    }


    <CLASS> Program

    {

        public void main()

        {

            Point p1 <NEW> Point(3,4);

            Point p2 <NEW> Point(5,6);

            Point p3 = Point.Add(p1,p2);


            p1.Print();

            <PRINTLN>("Dist=" + p1.DistanceFromOrigin());

            p2.Print();

            <PRINTLN>("Dist=" + p2.DistanceFromOrigin());

            p3.Print();


            Rectangle rect <NEW> Rectangle(p1,10,8);

            rect.Print();

            <PRINTLN>("Area=" + rect.Area());

            <PRINTLN>("Contains p1? " + rect.Contains(p1));

            <PRINTLN>("Contains (15,2)? " + rect.Contains(new Point(15,2)));

        }

    }

}

}


‚ú® Output (Console-like)


Point p1: (3,4)

Distance from origin: 5

Point p2: (5,6)

Distance from origin: 7.81024967590665

Point p3 (p1 + p2): (8,10)

Rectangle: Rect @ (3,4) w=10 h=8

Area: 80

Contains p1? True

Contains (15,2)? False


## üß© What the Program Does

Your program defines **two structures** (`Point` and `Rectangle`) and a **main class** (`Program`) that demonstrates how they work.


### 1. **Point Structure**

- **Fields:** `X` and `Y` (represent coordinates).  

- **Constructor:** Initializes a point with given `x` and `y` values.  

- **Method:** `DistanceFromOrigin()` calculates how far the point is from `(0,0)` using the distance formula.  

- **Static Method:** `Add(Point a, Point b)` creates a new point by adding the coordinates of two points.  

- **Print Method:** Displays the point in `(X,Y)` format.


üëâ This structure models a simple 2D point.


---


### 2. **Rectangle Structure**

- **Fields:** `TopLeft` (a `Point`), `Width`, and `Height`.  

- **Constructor:** Initializes a rectangle with position and size.  

- **Method:** `Area()` calculates the rectangle‚Äôs area.  

- **Method:** `Contains(Point p)` checks if a given point lies inside the rectangle.  

- **Print Method:** Displays rectangle details (position, width, height).


üëâ This structure models a rectangle in 2D space.


---


### 3. **Program Class**

- The `main()` method demonstrates usage:

  - Creates points (`p1`, `p2`, `p3`).  

  - Prints their coordinates and distances from origin.  

  - Creates a rectangle and prints its details.  

  - Checks if certain points are inside the rectangle.  


üîë Highlights

p1 and p2 are individual points with their distances calculated.

p3 is the sum of p1 and p2.

The rectangle is defined at (3,4) with width 10 and height 8.

The program checks whether points lie inside the rectangle.



## ‚ú® Key Takeaways

- **DotWeb5.0 structures** are similar to C# structs: lightweight, stack-based, and good for simple data models.  

- The program shows **object creation (`<NEW>`), printing (`<PRINTLN>`), and methods** in action.  

- It demonstrates **encapsulation**: grouping related data (coordinates, rectangle dimensions) with behaviors (distance, area, contains).  



## ‚ú® Why Use Structures?


- **Logical organization**: Keep related data together instead of scattering variables.  

- **Encapsulation**: Bundle information into a single unit for clarity.  

- **Readability & maintainability**: Code becomes easier to understand and manage.  

- **Efficiency**: Ideal for lightweight data models that don‚Äôt require inheritance.  


Note:
Dotweb5.0 contains Advanced Structures, which are better than Structure Type‚Äë1.

‚ú® Dotweb 5.0 ‚Äì J7Structure Type-2 Example
üìå Program Code
dotwebwithStructure.web

<WEB>

<PACK> dotwebsample

{

    <CLASS> example1

    {

        public void main()

        {

            <PRINTLN>("*************************************************************************");

            <PRINTLN>("J7Structure in Dotweb 5.0 is powerful, and it can store more records than any other structure.");

            <PRINTLN>("J7Structure in Dotweb 5.0");


            // Create a Structure named 'liste'

            CLIB.Structure liste <NEW> CLIB.Structure("Strutdatas");


            // Add 10 data elements to the structure

            for (int i11 = 0; i11 < 10; i11 = i11 + 1)

            {

                liste.add("data" + i11);

            }


            // Retrieve and print all elements from the structure

            for (int i11 = 0; i11 < liste.size(); i11 = i11 + 1)

            {

                Object el = liste.ret(i11);

                <PRINTLN>("SNO = " + el);

            }


            // Remove the 5th element

            liste.Remove(5);

            <PRINTLN>(liste);


            // Remove all elements

            liste = CLIB.Structure.RemoveAll(liste);

            <PRINTLN>(liste);


            // Check if the structure is empty

            <PRINTLN>(CLIB.Structure.isEmpty(liste));

        }

    }

}



üìñ Explanation
J7Structure in Dotweb 5.0 is a powerful data structure capable of storing more records than traditional structures.

A structure in Dotweb 5.0 is created using the following syntax:

CLIB.Structure structobj <NEW> CLIB.Structure(initialValue);



üñ•Ô∏è Program Output
*************************************************************************

J7Structure in Dotweb 5.0 is powerful, and it can store more records than any other structure.

J7Structure in Dotweb 5.0

SNO = Strutdatas

SNO = data0

SNO = data1

SNO = data2

SNO = data3

SNO = data4

SNO = data5

SNO = data6

SNO = data7

SNO = data8

SNO = data9

CLIB.Structure@189441b

True



üåü Key Highlights
‚úÖ Initialization: A structure is created with an initial value.

‚úÖ Data Insertion: Multiple records can be added dynamically.

‚úÖ Data Retrieval: Elements can be accessed using index-based retrieval.

‚úÖ Modification: Specific elements can be removed.

‚úÖ Cleanup: All elements can be cleared at once.

‚úÖ Validation: The structure provides a method to check if it is empty.


Note:  For DOTWEB5.0 Programming Language  ENLIGHT IDE  is used , it is  beautiful , easy  to  use  developed  by  Wilmix jemin J.

You can  see the  screenshot for  the  J7Structure for  your  reference...




Heap Data Structure

Heap data structures play an important role in securing data. 

Heap data structures display values in a tree format.

Syntax for Heap Data Structure

CLIB.Heap = new CLIB.Heap("Heap"); .add(data);


Example

Heapsample.web

<WEB>

<PACK> Javadtspart5

{

    <CLASS> J7Heap


    {

      public void main() {

        

      <PRINTLN>("HEAP  in  Java7.0");

      <PRINTLN>("=================="); 

      CLIB.Heap h <NEW> CLIB.Heap("Heap");

      CUTIL.ArrayList ar1 <NEW> CUTIL.ArrayList();

      for (int i=0;i<10;i++)

          ar1.add(i,i+3);

      h.add("wilmix1");

      h.add("wilmix2");

      h.add("wilmix3");

      h.add("wilmix4");

      h.add("wilmix5");

      h.add(ar1);

      CUTIL.ArrayList ar=h.get();

      <PRINTLN>( h);

      <PRINTLN>( ar);

}

}

}


Explanation

CLIB.Heap h = new CLIB.Heap("Heap"); h.add("wilmix1"); h.add("wilmix2"); h.add("wilmix3"); h.add("wilmix4"); h.add("wilmix5");

Here we initialize the heap with the name "Heap".
We then add the values wilmix1, wilmix2, wilmix3, wilmix4, wilmix5 to the heap.

When we print the heap object h, the original values are not displayed.
Instead, the output shows something like:

CLIB.Heap@189441b

To convert the heap values into a readable format, we use CUTIL.ArrayList:

CUTIL.ArrayList ar = h.get();

Using Dotweb3.0 / OakJava7 ArrayList

CUTIL.ArrayList ar1 = new CUTIL.ArrayList(); 

for (int i = 0; i < 10; i++)

 { 

ar1.add(i, i + 3); 

}

When you add this ArrayList to the heap:

h.add(ar1);

and print the heap:

<PRINTLN>(h);

The output will still look like:

CLIB.Heap@189441b

But when you call h.get(), the output is:

[[3, 4, 5, 6, 7, 8, 9, 10, 11, 12], wilmix5, wilmix4, wilmix3, wilmix2, wilmix1]

Final Combined Output

HEAP in Java 7.0 

================== 

CLIB.Heap@189441b 

[[3, 4, 5, 6, 7, 8, 9, 10, 11, 12], wilmix5, wilmix4, wilmix3, wilmix2, wilmix1]

Notes

You must include the J7LIB.dll file in the project properties.

This process generates an obfuscated file format (Heapsample.jclass) that cannot be reverse engineered or converted back to the real source code of Dotweb5.0 or OakJava7.

The advantage is that if you already know C# or Java, learning this system is straightforward. That is why Dotweb5.0 / OakJava7 (Java 7.0) is considered more secure than other programming languages.


======================================================================================================

üñ®Ô∏è Output



LinkedList


üìñ Definition

A linked list is a linear data structure in which elements, called nodes, are connected using pointers. Each node contains two parts:

‚Ä¢ 	Data: the actual value stored.

‚Ä¢ 	Reference (or pointer): a link to the next node in the sequence.

Unlike arrays, linked lists do not store elements in contiguous memory locations. Instead, nodes are scattered in memory and connected through references.


üîë Key Characteristics

‚Ä¢ 	Dynamic size: Can grow or shrink at runtime without reallocating memory.

‚Ä¢ 	Efficient insertion/deletion: Adding or removing nodes is faster compared to arrays, especially in the middle of the list.

‚Ä¢ 	Sequential access: Elements must be traversed one by one; random access is not possible.


I believe everyone is familiar with the concept of a linked list. It is important to understand the fundamentals of this data structure and how to implement it using the modern language Dotweb5.0.


LinkedSample.web


<WEB>


<PACK> Dotweb5Oj7dts

{

    <CLASS> LinkedList


    {

      public void main() {

        

      <PRINTLN>("===============================");    


    


 <PRINTLN>("LinkedList  in  Dotweb5.0 / Java7.0");


 CLIB.LinkedList  ll = new CLIB.LinkedList();


        ll.add("1011L");

        ll.add("1013L");

        ll.addFirst("10L");

        ll.addLast("20L");

        ll.addLast("30L");

        ll.addAtPosition(1, "15L"); // Insert 15 at index 1


        <PRINTLN>("List after additions:");

        ll.display();

        ll.removeFirst();//remove Ist element


        // remove() method will remove 

        // the head of the LinkedList

        ll.remove(); 


      <PRINTLN>("After removing first:");

        ll.display(); 


        ll.removeLast(); // Remove the Last element

        <PRINTLN>("After removing last:");

        ll.display();



<PRINTLN>("===============================");   




}



}


}


üñ•Ô∏è Program Output
===============================

LinkedList  in  Dotweb5.0 / Java7.0

List after additions:

10L -> 15L -> 1013L -> 1011L -> 20L -> 30L -> null

After removing firstElement:

1013L -> 1011L -> 20L -> 30L -> null

After removing lastElement:

1013L -> 1011L -> 20L -> null

===============================

===========================================================================================

Bag Data Structure


The Bag Data Structure is used to create a hierarchical tree-like structure.

For example, Peter is working as a software engineer at Company ABC. From his CEO, S. Andrew, down to Peter, there are 10 lead members in the hierarchy.

To represent such a hierarchy in a tree-like format, you can use the Bag Data Structure. While a traditional tree data structure can be complex, the Bag Data Structure provides a simpler way to achieve the same result.


Example

<WEB>

<PACK> Javadtspart5

{

    <CLASS> J7Bag


    {


public void main()  {

        

<PRINTLN>("Bag  in  Java7.0 / Dotweb5.0");


Bag  tree <NEW> Bag();

 Bag  Member <NEW> Bag();


Member.PUT("A","CLASS5");

Member.PUT("B","CLASS5");

Member.PUT("C","CLASS5");

Member.PUT("D","CLASS5");

Member.PUT("CLASS6","CLASS6");

Bag  slibings <NEW> Bag();

slibings.PUT("A","s1");

slibings.PUT("A","s2");

slibings.PUT("B","s11");

slibings.PUT("B","s21");

slibings.PUT("C","s12");

slibings.PUT("C","s22");

Bag  activity <NEW> Bag();

activity.PUT("s1","cricket");

activity.PUT("s2","read");

activity.PUT("s21","swim");

activity.PUT("s12","swim");

tree.PUT(1,Member);

tree.PUT(2,slibings);

tree.PUT(3,activity);

activity.remove("s1","cricket");

tree.remove(3,activity);

tree.PUT(3,activity);


<PRINTLN>("output="+tree.containsValue(Member));

<PRINTLN>("outputTree="+tree);

<PRINTLN>("===============================");   

}

}

}


Explanation

Root Creation

 Bag tree Bag();

This creates the root of the tree.

Child Members

Bag Member Bag(); Member.PUT("A","CLASS5"); Member.PUT("B","CLASS5"); Member.PUT("C","CLASS5"); Member.PUT("D","CLASS5"); Member.PUT("CLASS6","CLASS6"); Here, A, B, C, and D belong to CLASS5. CLASS6 has only one member.

Siblings

Bag siblings Bag(); siblings.PUT("A","s1"); siblings.PUT("A","s2"); siblings.PUT("B","s11"); siblings.PUT("B","s21"); siblings.PUT("C","s12"); siblings.PUT("C","s22");

A has siblings s1 and s2.

B has siblings s11 and s21.

C has siblings s12 and s22.

Activities

activity.PUT("s1","cricket"); activity.PUT("s2","read"); activity.PUT("s21","swim"); activity.PUT("s12","swim"); Each sibling is associated with an activity.

Hierarchy Assembly

tree.PUT(1, Member); tree.PUT(2, siblings); tree.PUT(3, activity); Members, siblings, and activities are added to the root tree.

Updating Activities

activity.remove("s1","cricket"); tree.remove(3, activity); tree.PUT(3, activity); For example, s1 stops playing cricket in 2005 and rejoins in 2025.

Validation and Output

        <PRINTLN>("output=" + tree.containsValue(Member)); <PRINTLN>("outputTree=" + tree);

Checks if Member is a child of the root tree.

Prints the entire tree hierarchy.

==============================================================================

üñ•Ô∏è Program Output


=============================================================================================================


                                          MATH SIN@  and   COS@ Operations and  J7ARRAYS  Datastructures

=============================================================================================================


J7ARRAYS Data Structures

This type of data structure is used to store items such as ArrayList and Structure types. It is capable of holding a large number of values compared to traditional arrays in most programming languages.


Write a DotWeb5.0 program that performs the following tasks:

Calculate and display the sine and cosine values of the number 10.

Create an ArrayList and add several elements to it.

Insert the ArrayList into a data structure.

Print the elements of in ascending order.

Print the elements of in descending order.

MathandJ7Arrays.web

<WEB>


<PACK> Program8

{

    <CLASS> Prog

    {

        public void main()

        {

            <PRINTLN>("===============================");


            // Use Math functions to find the Cosine and Sine values

            <PRINTLN>("Sin value = " + Math.Sin(10));

            <PRINTLN>("Cos value = " + Math.Cos(10));


            <PRINTLN>("===============================");


            // Create an ArrayList and add elements

            CUTIL.ArrayList ar = new CUTIL.ArrayList();

            ar.add(0, "wilmix1");

            ar.add(1, "wilmix2");

            ar.add(2, "wilmix3");

            ar.add(3, "wilmix4");

            ar.add(4, "wilmix5");


            <PRINTLN>("J7ARRAYS in Java7.0");


            // Create a J7ARRAYS object

            <J7ARRAYS> u = new <J7ARRAYS>("Wilmix");


            // Add integers and ArrayList elements to J7ARRAYS

            for (int i = 100; i > 0; i--)

            {

                u.add("" + i);                 // Add integers

                u.add("" + ar.ToString());     // Add ArrayList as string

            }


            // Retrieve specific elements

            <PRINTLN>("Value at position 5  = " + u.ret(5));

            <PRINTLN>("Value at position 11 = " + u.ret(11));

            <PRINTLN>("Value at position 45 = " + u.ret(45));


            // Sort in Ascending order and print

            u.ASCENDSORT();

            <PRINTLN>("Ascending Order: " + u.RET());


            // Sort in Descending order and print

            u.DESCENDSORT();

            <PRINTLN>("Descending Order: " + u.RET());


            <PRINTLN>("===============================");

        }

    }

}

üîé Step-by-Step Explanation

Program Start

Prints a separator line (===============================) to mark the beginning.

Math Functions

Uses Math.Sin(10) to calculate the sine of 10.

Uses Math.Cos(10) to calculate the cosine of 10.

Prints both results.

ArrayList Creation

Creates a CUTIL.ArrayList named ar.

Adds five string elements: "wilmix1", "wilmix2", "wilmix3", "wilmix4", "wilmix5".

J7ARRAYS Initialization

Creates a J7ARRAYS object u with the initial value "Wilmix".

Runs a loop from 100 down to 1:

Adds each integer (converted to string) into u.

Also adds the ArrayList contents as a string.

Element Retrieval

Retrieves and prints the element at position 5.

Retrieves and prints the element at position 11.

Retrieves and prints the element at position 45.

Sorting Demonstration

Sorts the J7ARRAYS in ascending order using ASCENDSORT().

Prints all values in ascending order with RET().

Sorts the J7ARRAYS in descending order using DESCENDSORT().

Prints all values in descending order with RET().

Program End

Prints another separator line (===============================) to mark the end.

üëâ In short, this program shows math operations (sin & cos), array handling, element retrieval, and sorting in DotWeb5.0.


üñ•Ô∏è Program Output

===============================

Sin value = -0.54402111088937

Cos value = -0.839071529076452

===============================

J7ARRAYS  in  Java7.0

Value=96

Value=90

56

[1, 10, 100, 11, 12, 13, 14, 15, 16, 17, 18, 19, 2, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 3, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 4, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 5, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 6, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 7, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 8, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 9, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, [wilmix1, wilmix2, wilmix3, wilmix4, wilmix5]]

[[wilmix1, wilmix2, wilmix3, wilmix4, wilmix5], 99, 98, 97, 96, 95, 94, 93, 92, 91, 90, 9, 89, 88, 87, 86, 85, 84, 83, 82, 81, 80, 8, 79, 78, 77, 76, 75, 74, 73, 72, 71, 70, 7, 69, 68, 67, 66, 65, 64, 63, 62, 61, 60, 6, 59, 58, 57, 56, 55, 54, 53, 52, 51, 50, 5, 49, 48, 47, 46, 45, 44, 43, 42, 41, 40, 4, 39, 38, 37, 36, 35, 34, 33, 32, 31, 30, 3, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 2, 19, 18, 17, 16, 15, 14, 13, 12, 11, 100, 10, 1]





# üìò Mask Data Structure


---


## 1Ô∏è‚É£ Introduction

The **Mask Data Structure (Mask DTS)** is a **tree-based data structure** that also supports integration with **ArrayLists** and other structural elements.  

- It **preserves insertion order**.  

- Each Mask DTS instance consists of **two keys**:  

  - **Primary Key** ‚Üí the main identifier.  

  - **Random Key** ‚Üí an auxiliary identifier.  

- After defining keys, you can pass **integers, strings, or any data type** into the structure.  


---


## 2Ô∏è‚É£ Example Usage


Write a dotweb5.0 program to  create two array lists and add 10 datas to mask dts and add 

3 set of  values and Mask dts will print in tree format automatically.


Consider the following example:  


Maskexample.web

===============


<WEB>


<PACK> Makexample

{


public <CLASS> Makdts

{


public void main()

{

<PRINTLN>("===============================");


<PRINTLN>("MASK  in  Java7.0");


 CLIB.MASK root <NEW> CLIB.MASK("root1");



CLIB.MASK root1 <NEW> CLIB.MASK("root2");


		// Add 10 datas to the ArrayList

CUTIL.ArrayList ar1 <NEW> CUTIL.ArrayList();

      for (int i=0;i<10;i++)

          ar1.add(i,i+3);


// Add 10 datas to the ArrayList

CUTIL.ArrayList ar11 <NEW> CUTIL.ArrayList();

      for (int i=0;i<10;i++)

          ar11.add(i,i+5);


root.add("TreeA");

root1.add("TreeB");


//print the tree's size 

		<PRINTLN>(root.size() );


//print the tree's size 

		<PRINTLN>(root1.size() );


              //Here string root1 is the key and 45678 is the data and ar1 contains Arraylist data

           root <NEW> CLIB.MASK("root1",ar1,45678);

		

		root  <NEW> CLIB.MASK("root2",ar11,45679);

		root  <NEW> CLIB.MASK("root5",99121888,"5");

		

		root1  <NEW> CLIB.MASK("root3",12112,544);

		

		root1  <NEW> CLIB.MASK("root4",1211,54);

		

		root1  <NEW> CLIB.MASK("root51",121,5);

                          

<PRINTLN>("===============================");


}


}


}


Note:


```java

root <NEW> CLIB.MASK("root1", ar1, 45678);

```


- Here, `"root1"` is the **primary key**.  

- `45678` is the **data value**.  

- `ar1` contains **ArrayList data**.  


This demonstrates that multiple sets of values can be added to the Mask Data Structure.  

When values are added using the same instance (`root` or `root1`), the structure returns a **tree-format data type** as output.


## 3Ô∏è‚É£ Output Behavior

The Mask DTS prints input values in **tree format** while maintaining **insertion order**.  


---


## 4Ô∏è‚É£ Sample Output (Java 7.0)


```text

MASK in Java7.0

2

2

[-8526742942261834865->

-8526742942261834865->

-8526742942261834865]

[root1->

root1->

root1]

[-8526742942261834865->

45678->

[[3, 4, 5, 6, 7, 8, 9, 10, 11, 12]]]

[2460193834502673226->

2460193834502673226->

2460193834502673226]

[root2->

root2->

root2]

[2460193834502673226->

45679->

[[5, 6, 7, 8, 9, 10, 11, 12, 13, 14]]]

[4202369142879245978->

4202369142879245978->

4202369142879245978]

[root5->

root5->

root5]

[4202369142879245978->

5->

[99121888]]

[6731882546062678810->

6731882546062678810->

6731882546062678810]

[root3->

root3->

root3]

[6731882546062678810->

544->

[12112]]

[3854722413359444045->

3854722413359444045->

3854722413359444045]

[root4->

root4->

root4]

[3854722413359444045->

54->

[1211]]

[-660321338655634768->

-660321338655634768->

-660321338655634768]

[root51->

root51->

root51]

[-660321338655634768->

5->

[121]]

```


---


## 5Ô∏è‚É£ Key Takeaways

- ‚úÖ **Tree-based structure** with insertion order preserved.  

- ‚úÖ Supports **multiple data types** (Integer, String, ArrayList, etc.).  

- ‚úÖ Each entry is defined by **two keys** (Primary + Random).  

- ‚úÖ Output is always in **tree format**.  


---


# üå≥ Mask Data Structure ‚Äî Tree Representation


```

MaskDTS (Root)

‚îÇ

‚îú‚îÄ‚îÄ root1 (Primary Key)

‚îÇ   ‚îú‚îÄ‚îÄ RandomKey: -8526742942261834865

‚îÇ   ‚îú‚îÄ‚îÄ Value: 45678

‚îÇ   ‚îî‚îÄ‚îÄ ArrayList: [3, 4, 5, 6, 7, 8, 9, 10, 11, 12]

‚îÇ

‚îú‚îÄ‚îÄ root2 (Primary Key)

‚îÇ   ‚îú‚îÄ‚îÄ RandomKey: 2460193834502673226

‚îÇ   ‚îú‚îÄ‚îÄ Value: 45679

‚îÇ   ‚îî‚îÄ‚îÄ ArrayList: [5, 6, 7, 8, 9, 10, 11, 12, 13, 14]

‚îÇ

‚îú‚îÄ‚îÄ root5 (Primary Key)

‚îÇ   ‚îú‚îÄ‚îÄ RandomKey: 4202369142879245978

‚îÇ   ‚îú‚îÄ‚îÄ Value: 5

‚îÇ   ‚îî‚îÄ‚îÄ ArrayList: [99121888]

‚îÇ

‚îú‚îÄ‚îÄ root3 (Primary Key)

‚îÇ   ‚îú‚îÄ‚îÄ RandomKey: 6731882546062678810

‚îÇ   ‚îú‚îÄ‚îÄ Value: 544

‚îÇ   ‚îî‚îÄ‚îÄ ArrayList: [12112]

‚îÇ

‚îú‚îÄ‚îÄ root4 (Primary Key)

‚îÇ   ‚îú‚îÄ‚îÄ RandomKey: 3854722413359444045

‚îÇ   ‚îú‚îÄ‚îÄ Value: 54

‚îÇ   ‚îî‚îÄ‚îÄ ArrayList: [1211]

‚îÇ

‚îî‚îÄ‚îÄ root51 (Primary Key)

    ‚îú‚îÄ‚îÄ RandomKey: -660321338655634768

    ‚îú‚îÄ‚îÄ Value: 5

    ‚îî‚îÄ‚îÄ ArrayList: [121]

```


---


## üîë How to Read This Diagram

- **Primary Key (rootX)** ‚Üí The main identifier for each node.  

- **Random Key** ‚Üí A unique secondary identifier.  

- **Value** ‚Üí An integer or string associated with the node.  

- **ArrayList** ‚Üí A collection of values stored under the node.  


---


## üìå Professional Notes

- This structure is **hierarchical** and **ordered by insertion**.  

- Each node can hold **multiple data types**.  

- The **tree format output** makes traversal and visualization straightforward.  

============================================================================================================

                                                                                PIPE  Datastructure  With CLASS

=============================================================================================================

üö¶ Pipe
üéØ Purpose
Maintains stateful behavior.

Supports data flow between classes.

Can add constructor values, method values, or object values from multiple classes and display them.


üìù Syntax
Pipe<> list = Pipe<>(STRING);

list.KeyAdd();

list.add();

list.RandomAdd();

list.Display(list);



üíª Example: pipeexample.web
<WEB>


<PACK> pipesn

{

    public <CLASS> PipeA {

        public string getValues() {

            <PRINTLN>("I am PIPE A");

            return "Positive";

        }

    }


    public <CLASS> PipeC : PipeA {

        public string getValues() {

            <PRINTLN>("I am PIPE C");

            return "Negative";

        }

    }


    public <CLASS> PipeB {

        public string getValues() {

            <PRINTLN>("I am PIPE B");

            return "Medium";

        }

    }


    public <CLASS> Pipefinal {

        public void main() {

            <PRINTLN>("PIPE in Java7.0");


            Pipe pipe <NEW> Pipe("BUCKETS");

            PipeA pipes1 <NEW> PipeC();

            PipeB pipes2 <NEW> PipeB();


            pipe.KeyAdd("1101");

            pipe.add(pipes1);

            pipe.RandomAdd();

            pipe.Display(pipe);

            <PRINTLN>("" + pipe.DisplayO(pipe,0));


            Pipe pipe1 <NEW> Pipe("BUCKETS1");

            pipe1.KeyAdd("1102");

            pipe1.add(pipes2);

            pipe1.RandomAdd();

            pipe1.Display(pipe1);

            <PRINTLN>("" + pipe1.DisplayO(pipe1,1));


            Pipe pipe2 <NEW> Pipe("BUCKETS of Pipe");

            pipe2.KeyAdd("129089");

            pipe2.add(pipes1.getValues());

            pipe2.add(pipes2.getValues());

            pipe2.RandomAdd();

            pipe2.Display(pipe2);

            <PRINTLN>("" + pipe2.DisplayO(pipe2,1));

        }

    }

}



üìñ Explanation
pipe.KeyAdd("1101"); ‚Üí Adds key 1101.

pipe.add(pipes1); ‚Üí Adds object pipes1.

pipe.RandomAdd(); ‚Üí Adds a random number manually.

pipe.Display(pipe); ‚Üí Displays the pipe values.

pipe.DisplayO(pipe,0); ‚Üí Displays the value at location 0.

üëâ Note:

PipeA pipes1 <NEW> PipeC(); means PipeC inherits from PipeA.

The getValues() method is overridden in PipeC.

When invoked, it executes the child class method (PipeC) instead of the parent (PipeA).


üìê UML Class Diagram (Text Representation)


                ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê

                ‚îÇ       PipeA           ‚îÇ

                ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§

                ‚îÇ + getValues(): string ‚îÇ

                ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ≤‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

                            ‚îÇ (inherits)

                            ‚îÇ

                ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê

                ‚îÇ       PipeC           ‚îÇ

                ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§

                ‚îÇ + getValues(): string ‚îÇ

                ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò



                ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê

                ‚îÇ       PipeB           ‚îÇ

                ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§

                ‚îÇ + getValues(): string ‚îÇ

                ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò



                ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê

                ‚îÇ         Pipefinal           ‚îÇ

                ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§

                ‚îÇ + main(): void              ‚îÇ

                ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

                            ‚îÇ uses

                            ‚îÇ

        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê

        ‚îÇ                   ‚îÇ                   ‚îÇ

   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê

   ‚îÇ  Pipe    ‚îÇ        ‚îÇ  PipeA   ‚îÇ        ‚îÇ  PipeB   ‚îÇ

   ‚îÇ (object) ‚îÇ        ‚îÇ / PipeC  ‚îÇ        ‚îÇ          ‚îÇ

   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò



üîπ Explanation


‚Ä¢ 	PipeA: Base class with  returning .

‚Ä¢ 	PipeC: Inherits from , overrides  returning .

‚Ä¢ 	PipeB: Independent class with  returning .

‚Ä¢ 	Pipefinal: Contains  method. Creates  objects and uses  and .


‚ú® This diagram shows both inheritance (PipeC ‚Üí PipeA) and usage relationships (Pipefinal uses Pipe, PipeA/PipeC, PipeB).


üñ•Ô∏è Pipe Output
PIPE in Java7.0

[8929290914726757639->8929290914726757639->8929290914726757639]

[BUCKETS->BUCKETS->BUCKETS]

[1101->1101->pipesn.PipeC]

[BUCKETS->BUCKETS->BUCKETS]

[1101->1101->pipesn.PipeC]

[BUCKETS->BUCKETS->BUCKETS]

[4381897666345927633->4381897666345927633->4381897666345927633]

[BUCKETS1->BUCKETS1->BUCKETS1]

[1102->1102->pipesn.PipeB]

[BUCKETS1->BUCKETS1->BUCKETS1]

[1102->1102->pipesn.PipeB]

[1102->pipesn.PipeB->1102]

[4287233612369726592->4287233612369726592->4287233612369726592]

 I am PIPE A

 I am PIPE B

[BUCKETS of Pipe->BUCKETS of Pipe->BUCKETS of Pipe]

[129089->129089->Positive]

[BUCKETS of Pipe->BUCKETS of Pipe->BUCKETS of Pipe]

[129089->129089->Positive]

[129089->Positive->129089]



üîë Key Takeaways for Technical Folks
Pipe acts like a container that can hold keys, objects, and values.

Inheritance works as expected: child class overrides parent‚Äôs method.

RandomAdd introduces variability in stored values.

Display & DisplayO provide structured output and indexed retrieval.


===========================================================================================================


                                                                                                        EXTEND  DATASTRUCTURE

======================================================================================


üìò EXTEND Datastructure

üîπ Overview

Extend behaves like Encapsulation in Java/.Net.

Supports Add and Read operations (‚ùå Delete not allowed).

Provides multiple inheritance (up to 100,000,000 classes).

Functions like a Bucket containing classes with methods and values.

Uses super key for values of any type.

String values can be used as Table Headers.

Allows adding class objects and random keys.

üîπ Example Behavior

Adding A1, A2 class objects produces:

Exdexample.extendprog1+A1 Exdexample.extendprog1+A2 Instantiating class A15 and calling A15Print() prints:

Iam a Young fellow

and returns:

Iam Age A15


Write a Dotweb5.0 Program using Extend datastructure  add Randomkey,Values,15 Class with 15 methods and class objects.                  


‚öôÔ∏è Program: Extendexample.web

<WEB>

<PACK> Exdexample

{

<CLASS> extendprog1

{


public void main()

{


<PRINTLN>("===============================");

<PRINTLN>("EXTEND  in  Java7.0");


CLIB.EXTEND list <NEW> CLIB.EXTEND("jem");

	

		      list.KeyAdd("1101");  

                    

                     list.add("SNO,");

                     list.add("SchoolName,");

                     list.add("StudentName,");

                     list.add("Section A,");

                     list.add("Subject1,");

                     list.add("Subject2,");

                     list.add("Subject3,");

                     list.add("Subject4,");

                     list.add("Subject5,");

                    list.add("TotalMark,");

                    list.add("Status,");

                    list.add("GRADE");

                    list.RandomAdd(); 

                    <PRINTLN>("*************************************************************************");


                     list.add("[");

                     list.add("1,");

                     list.add("EDWillMottSchool,");

                     list.add("Andrew,");

                     list.add("A1,");

                     list.add("75,");

                     list.add("75,");

                     list.add("75,");

                     list.add("75,");

                     list.add("75,");

                    list.add("375,");

                    list.add("Distinction,");

                    list.add("B"); 

                     list.add("]");

                    list.RandomAdd();   

                    list.KeyAdd("Schools");                   

                    list.add(new A1());

                    list.add(new A2());

                    list.add(new A3());

                    list.add(new A4());

                    list.add(new A5());

                    list.add(new A6());

                    list.add(new A7());

                    list.add(new A8());

                    list.add(new A9());

                    list.add(new A10());

                     

                    list.add(new A11());

                    list.add(new A12());

                    list.add(new A13());

                    list.add(new A14());

                    A15 a15 <NEW> A15();

                    list.add(a15.A15Print());

                    

<PRINTLN>("For Extend we  can store and retrieve the data , but can't  delete it");                                    

<PRINTLN>("*************************************************************************");

for(int i=0;i<list.sizefordata();i++)

                    

<PRINTLN>(""+ list.getVal(i));


<PRINTLN>("*************************************************************************");


}

// 15 classes and  15 methods

public <CLASS> A1

{


public void A1Print()

{


<PRINTLN>("Iam A1");

}


}


public <CLASS> A2

{


public void A2Print()

{


<PRINTLN>("Iam A2");

}


}


public <CLASS> A3

{


public void A3Print()

{


<PRINTLN>("Iam A3");

}


}


public <CLASS> A4

{


public void A4Print()

{


<PRINTLN>("Iam A4");

}


}


public <CLASS> A5

{


public void A5Print()

{


<PRINTLN>("Iam A5");

}


}


public <CLASS> A6

{


public void A6Print()

{


<PRINTLN>("Iam A6");

}


}


public <CLASS> A7

{


public void A7Print()

{


<PRINTLN>("Iam A7");

}


}



public <CLASS> A8

{


public void A8Print()

{


<PRINTLN>("Iam A8");

}


}


public <CLASS> A9

{


public void A9Print()

{


<PRINTLN>("Iam A9");

}


}


public <CLASS> A10

{


public void A10Print()

{


<PRINTLN>("Iam A10");

}


}


public <CLASS> A11

{


public void A11Print()

{


<PRINTLN>("Iam A11");

}


}


public <CLASS> A12

{


public void A12Print()

{


<PRINTLN>("Iam A12");

}


}


public <CLASS> A13

{


public void A13Print()

{


<PRINTLN>("Iam A13");

}


}



public <CLASS> A14

{


public void A14Print()

{


<PRINTLN>("Iam A14");

}


}


public <CLASS> A15

{


public string A15Print()

{


<PRINTLN>("Iam a Young fellow");

return("Iam Age A15");

}

}

}

}


üîÑ Flow Diagram: Extend Datastructure
               ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê

                ‚îÇ   EXTEND Datastructure ‚îÇ

                ‚îÇ   (Bucket of Classes)  ‚îÇ

                ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

                            ‚îÇ

        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê

        ‚îÇ                   ‚îÇ                   ‚îÇ

   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê

   ‚îÇ  KeyAdd  ‚îÇ        ‚îÇ RandomAdd‚îÇ        ‚îÇ   Add    ‚îÇ

   ‚îÇ (Assign  ‚îÇ        ‚îÇ (Insert  ‚îÇ        ‚îÇ (Insert  ‚îÇ

   ‚îÇ Unique   ‚îÇ        ‚îÇ Random   ‚îÇ        ‚îÇ Values & ‚îÇ

   ‚îÇ Keys)    ‚îÇ        ‚îÇ Entries) ‚îÇ        ‚îÇ Objects) ‚îÇ

   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚ñ≤‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚ñ≤‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚ñ≤‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

        ‚îÇ                   ‚îÇ                   ‚îÇ

        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

                    ‚îÇ               ‚îÇ

             ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê

             ‚îÇ Class Obj   ‚îÇ   ‚îÇ String/Int ‚îÇ

             ‚îÇ (A1‚ÄìA15)    ‚îÇ   ‚îÇ Values     ‚îÇ

             ‚îÇ Methods ‚Üí   ‚îÇ   ‚îÇ (Headers,  ‚îÇ

             ‚îÇ Output Data ‚îÇ   ‚îÇ Marks etc.)‚îÇ

             ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ≤‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚ñ≤‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

                    ‚îÇ               ‚îÇ

                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

                            ‚îÇ

                  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê

                  ‚îÇ   Retrieval Only   ‚îÇ

                  ‚îÇ   (No Deletion)    ‚îÇ

                  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò



üîπ Explanation of Flow

EXTEND Datastructure acts as a central bucket.

KeyAdd ‚Üí Assigns unique keys to stored data.

RandomAdd ‚Üí Inserts random entries for variety.

Add ‚Üí Allows insertion of values (headers, marks, etc.) and class objects.

Class Objects (A1‚ÄìA15) ‚Üí Each has its own method, producing outputs like "Iam A1", "Iam a Young fellow".

Retrieval ‚Üí Data can be read back in sequence.

‚ùå No Deletion ‚Üí Once added, data stays permanently.


‚ú® This diagram shows the data flow from class methods and values into the Extend bucket, and how retrieval works.



üñ•Ô∏è Output


===============================

EXTEND  in  Java7.0

[-802204435687571817->

-802204435687571817->

-802204435687571817]

*************************************************************************

Iam a Young fellow

For Extend we  can store and retrieve the data , but can't  delete it

*************************************************************************

jem

SNO,

SchoolName,

StudentName,

Section A,

Subject1,

Subject2,

Subject3,

Subject4,

Subject5,

TotalMark,

Status,

GRADE

[

1,

EDWillMottSchool,

Andrew,

A1,

75,

75,

75,

75,

75,

375,

Distinction,

B

]

Exdexample.extendprog1+A1

Exdexample.extendprog1+A2

Exdexample.extendprog1+A3

Exdexample.extendprog1+A4

Exdexample.extendprog1+A5

Exdexample.extendprog1+A6

Exdexample.extendprog1+A7

Exdexample.extendprog1+A8

Exdexample.extendprog1+A9

Exdexample.extendprog1+A10

Exdexample.extendprog1+A11

Exdexample.extendprog1+A12

Exdexample.extendprog1+A13

Exdexample.extendprog1+A14

Iam Age A15

*************************************************************************


=========================================================================================================

                                                                                                    LARRAY DATASTRUCTURE

===============================================================================================================

üåü DotWeb 5.0 Program: ArraysExample

‚ú® Introduction

In this program, we explore the use of LArray from the CLIB package and compare it with the ArrayList from the CUTIL and packages.
The focus is on how LArray differs from a traditional ArrayList in terms of data handling, printing, and flexibility.

üîç What is the Use of LArray?

LArray belongs to the CLIB package.

Unlike ArrayList, which can only store one datatype at a time, LArray allows multiple datatypes such as integers, strings, and ArrayList data.

However, LArray does not accept objects; it only works with primitive values and collections.

It also has a unique feature: it can print data in a tree format, which is not possible with a standard ArrayList.

üéØ Why Do We Focus on LArray?

We focus on LArray because:

It provides flexibility in storing mixed datatypes.

It supports tree-format printing, making data visualization easier.

It allows removal of elements and returns them as an .ArrayList, which can then be manipulated further (e.g., removing the 2nd element with ar55.remove(1)).


üíª DotWeb 5.0 Program Code


ArraysExample.web

<WEB>

<PACK> ArraysExample

{

    public <CLASS> StandardArray

    {

        public void main()

        {

            CLIB.LArray larray = new CLIB.LArray("school");

            CUTIL.ArrayList arraylist = new CUTIL.ArrayList();


            for(int i = 0; i < 10; i++)

                arraylist.add(i, i);


            larray.add("wilmix");

            larray.add("jemin");

            larray.add("shalom");

            larray.add("1010");

            larray.add("101");

            larray.add("201");

            larray.add(arraylist.ToString());

            larray.add("100000000");

            larray.add(arraylist.ToString());


            larray.printTree();


            <OJ7UTIL>.ArrayList ar55 = larray.remove("201");

            <PRINTLN>(ar55);


            ar55.remove(1);

            <PRINTLN>(ar55);


            <PRINTLN>("*************************************************************************");

        }

    }

}



üìä Output

[shalom, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], jemin, 101, school, 100000000, wilmix, 1010]

[shalom, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], jemin, 101, school, 100000000, wilmix, 1010]


üåü Key Attractions

‚Ä¢ 	LArray vs ArrayList: LArray supports multiple datatypes and tree-format printing, while ArrayList is limited to one datatype.

‚Ä¢ 	Element Removal: Removing  returns an ArrayList () that can be further modified.

‚Ä¢ 	Flexibility: LArray allows adding integers, strings, and ArrayList data together.

‚Ä¢ 	Tree Printing: A unique feature that makes data representation more structured.


üìê UML Class Diagram (Textual Representation)


+-------------------+

|      LArray       |   <<class>> (CLIB package)

+-------------------+

| - elements : List |

+-------------------+

| + add(value)      |

| + remove(value)   : ArrayList (OJ7UTIL) |

| + printTree()     |

+-------------------+

          |

          | uses

          v

+-------------------+

|    ArrayList      |   <<class>> (CUTIL / OJ7UTIL package)

+-------------------+

| - items : List    |

+-------------------+

| + add(index, val) |

| + remove(index)   |

| + toString()      |

+-------------------+


üîé Explanation of Relationships

‚Ä¢ 	LArray ‚Üí ArrayList

‚Ä¢ 	 internally uses  for storing and manipulating values.

‚Ä¢ 	When you call  on , it returns an  object from the  package.

‚Ä¢ 	Attributes

‚Ä¢ 	 ‚Üí Represents the internal storage of values (Strings, Integers, ArrayList data).

‚Ä¢ 	Methods

‚Ä¢ 	 ‚Üí Adds a new element (supports multiple datatypes except objects).

‚Ä¢ 	 ‚Üí Removes an element and returns it as an .

‚Ä¢ 	 ‚Üí Prints the elements in a tree-like structure.


üåü Attraction Points

‚Ä¢ 	Flexibility: Unlike a normal ,  can store mixed datatypes.

‚Ä¢ 	Tree Printing: Provides a structured visualization of data.

‚Ä¢ 	Integration: Works seamlessly with from  and  packages.


==============================================================================================================                                                                                                                         

                                                                                    TREE  DATASTRUCTURE

===============================================================================================================


A tree data structure is a hierarchical model used in computer science to organize data in a parent‚Äìchild relationship, where the topmost node is called the root and each node may have zero or more children. It is widely used for representing hierarchical data such as file systems, organizational charts, and databases.


üå≥ Definition of Tree Data Structure

‚Ä¢ 	A tree is a non-linear data structure consisting of nodes connected by edges.

‚Ä¢ 	The root node is the topmost node, with no parent.

‚Ä¢ 	Each node can have child nodes, and those children can themselves be roots of subtrees.

‚Ä¢ 	There are no cycles in a tree, meaning no node can be its own ancestor.

‚Ä¢ 	Trees are often visualized upside down compared to real trees, with the root at the top and branches extending downward.


üîë Key Terminologies

‚Ä¢ 	Root Node: The starting point of the tree (e.g.,  in a file system).

‚Ä¢ 	Parent Node: A node that has children.

‚Ä¢ 	Child Node: A node that descends from a parent.

‚Ä¢ 	Leaf Node: A node with no children (end of a branch).

‚Ä¢ 	Subtree: A smaller tree structure within a larger tree.

‚Ä¢ 	Depth: The number of edges from the root to a node.

‚Ä¢ 	Height: The longest path from the root to a leaf.


‚ö° Applications of Trees

File Systems: Organizing directories and files.

Databases: Indexing and searching (e.g., B-trees).

Networking: Routing tables and hierarchical structures.

Artificial Intelligence: Decision trees for machine learning.

Compilers: Abstract syntax trees for parsing code.


üöÄ Why Trees Are Important

‚Ä¢ 	They allow efficient searching and sorting.

‚Ä¢ 	They represent hierarchical relationships naturally.

‚Ä¢ 	They support recursive algorithms due to their branching structure.

‚Ä¢ 	They are foundational in data indexing, AI, and operating systems.


Note: In short, a tree is a hierarchical, non-linear data structure made of nodes and edges, ideal for representing relationships and enabling efficient operations in computing.


Write a  Dotweb5.0 Program  to create a Tree  and 10 elements  , print the tree's size and contents

TreeExample.web

<WEB>

 

<PACK> TreeExample

{

public <CLASS> CreateTree

{

public void main()

{

   <PRINTLN>("*************************************************************************");


<PRINTLN>("Tree  in  Java7.0");


//create the tree

		CLIB.Tree roots <NEW> CLIB.Tree("root");

		for (int i = 0; i < 10; i = i + 1)

		{

			roots.add("item " + i);

		}


		//print the tree's size and contents

		<PRINTLN>(roots.size() + "\n\n");       

                <PRINTLN>(CLIB.Tree.datas + "\n\n");

}


}


}



üìä Output


 11


[item 5, item 9, item 1, item 3, item 7, root, item 4, item 8, item 0, item 2, item 6]


üé® Beautified Layout


                üü¢ root

        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê

      üîµ item 5   üîµ item 9   üîµ item 1

       /   \       /   \       /   \

   üü° item 3 üü° item 7 üü° item 4 üü° item 8 üü° item 0

                          / \

                     üü° item 2 üü° item 6


‚ú® Highlights


Root Node ‚Üí root

Children Nodes ‚Üí item 5, item 9, item 1

Leaf Nodes ‚Üí item 3, item 7, item 4, item 8, item 0, item 2, item 6

Total Nodes ‚Üí 11



=============================================================================================

      Basic DataStructures Simillar to  Java for Java Professionals

============================================================================================


Define HashMap in Dotweb5.0

In Dotweb5.0 and Java, a HashMap is a data structure that stores elements in key‚Äìvalue pairs,

 where each key is unique and maps to exactly one value. 

The Dotweb Collections Framework, implements the Map interface, and internally uses hashing 

to provide fast lookups, insertions, and deletions (average time complexity O(1)).


üß© Key Characteristics of HashMap

‚Ä¢ 	Keys are unique ‚Üí No duplicate keys allowed.

‚Ä¢ 	Values can be duplicated ‚Üí Multiple keys can map to the same value.

‚Ä¢ 	Nulls allowed ‚Üí One  key and multiple  values are permitted.

‚Ä¢ 	Unordered ‚Üí Does not preserve insertion order. If you need order, use .

‚Ä¢ 	Not thread-safe ‚Üí Concurrent access must be synchronized externally or use .

‚Ä¢ 	Performance ‚Üí Average O(1) for put() ,get() , and remove() operations under good hash distribution.


‚ö° Example Usage

Write  a  Hashmap  program  in Dotweb 5.0  to add  the key and values [Alice=25, Bob=30, Charlie=20, David=40]  and  Sort by Key and  Value  Ascending and  Descending respectively. And  get the value of  Alice.

And remove Alice key and value. And finaly check where  Alice key and  value exists or not.


Program

<PRINTLN>("------------------------------------------------------------------------------------");


<PRINTLN>("                 J7HashMap  EXAMPLES                          ");

<PRINTLN>("------------------------------------------------------------------------------------");


OJ7Lib.J7HashMap map99 = new OJ7Lib.J7HashMap();


        map99.put("Alice", 25);

        map99.put("Bob", 30);

        map99.put("Charlie", 20);

        map99.put("David", 40);


<PRINTLN>("Sorted by Key Ascending:");


map99.printSortedByKeyAsc();

<PRINTLN>("Sorted by Key Descending:");

map99.printSortedByKeyDesc();


<PRINTLN>("Sorted by Value Ascending:");

map99.printSortedByValueAsc();

<PRINTLN>("Sorted by Value Descending:");

map99.printSortedByValueDesc();


<PRINTLN>(map99.get("Alice"));


map99.remove("Alice");

<PRINTLN>(map99.containsKey("Alice")); // true


üß© Program Breakdown


1. Printing a Header


<PRINTLN>("------------------------------------------------------------------------------------");

<PRINTLN>("                 J7HashMap  EXAMPLES                          ");

<PRINTLN>("------------------------------------------------------------------------------------");

This simply prints a decorative header to the console, marking the start of the demo.

2. Creating a J7HashMap

OJ7Lib.J7HashMap map99 = new OJ7Lib.J7HashMap();

map99 is an instance of your custom J7HashMap class (similar to Java‚Äôs HashMap).

It will store key‚Äìvalue pairs where keys are names (String) and values are ages (Integer).

3. Adding Entries

map99.put("Alice", 25); map99.put("Bob", 30); map99.put("Charlie", 20); map99.put("David", 40);

Four entries are inserted into the map:

"Alice" ‚Üí 25

"Bob" ‚Üí 30

"Charlie" ‚Üí 20

"David" ‚Üí 40

4. Sorting by Keys

<PRINTLN>("Sorted by Key Ascending:");

map99.printSortedByKeyAsc();

<PRINTLN>("Sorted by Key Descending:");

map99.printSortedByKeyDesc();


Ascending ‚Üí Keys will be printed in alphabetical order: Alice, Bob, Charlie, David.

Descending ‚Üí Keys will be printed in reverse alphabetical order: David, Charlie, Bob, Alice.

5. Sorting by Values

<PRINTLN>("Sorted by Value Ascending:");

map99.printSortedByValueAsc();

<PRINTLN>("Sorted by Value Descending:");

map99.printSortedByValueDesc();

Ascending ‚Üí Values sorted numerically: Charlie=20, Alice=25, Bob=30, David=40.

Descending ‚Üí Reverse order: David=40, Bob=30, Alice=25, Charlie=20.

6. Accessing a Value

<PRINTLN>(map99.get("Alice"));

Retrieves the value for key "Alice".

Output: 25.


7. Removing an Entry

map99.remove("Alice");

Deletes the entry for "Alice" from the map.

8. Checking Existence

<PRINTLN>(map99.containsKey("Alice")); // true


After removal, this checks if "Alice" still exists.

Since she was removed, the result should be false (the comment // true looks incorrect).


‚ö° Expected Output (Simplified)

------------------------------------------------------------------------------------

                 J7HashMap  EXAMPLES                          

------------------------------------------------------------------------------------

Sorted by Key Ascending:

Alice=25

Bob=30

Charlie=20

David=40


Sorted by Key Descending:

David=40

Charlie=20

Bob=30

Alice=25


Sorted by Value Ascending:

Charlie=20

Alice=25

Bob=30

David=40


Sorted by Value Descending:

David=40

Bob=30

Alice=25

Charlie=20

25

false


Note: 

So this program demonstrates basic HashMap operations (put, get, remove, containsKey) plus custom sorting methods (printSortedByKeyAsc/Desc, printSortedByValueAsc/Desc) that your J7HashMap class provides.


Define  Concurrent HashMap

A ConcurrentHashMap in Java is a thread‚Äësafe implementation of the  interface that allows multiple threads to read and write data simultaneously without locking the entire map. It is designed for high‚Äëconcurrency environments where many threads need to access and modify shared data safely.

‚ö° Example Usage

Program


<PRINTLN>("------------------------------------------------------------------------------------");

<PRINTLN>("                 J7Concurrent HashMap  EXAMPLES                          ");

<PRINTLN>("------------------------------------------------------------------------------------");

OJ7Lib.J7ConcurrentHashMap map19 = new OJ7Lib.J7ConcurrentHashMap(16);

        // put and get

        map19.put("A", 1);

        <PRINTLN>(map19.get("A"));

    map19 = map19.ComputeIfAbsent(map19, "B", "42");

    <PRINTLN>(map19.get("B")); 

    map19 = map19.ComputeIfPresent(map19, "A", "46");

    <PRINTLN>(map19.get("A")); 


    map19 = map19.Merge(map19, "B", " ", 3);

    <PRINTLN>(map19.get("B")); 


    map19 = map19.Visit(map19, "", "");

    <PRINTLN>(map19.get("A")); 


map19.remove("B");


if (map19.get("B")NOT=null)


  <PRINTLN>("The  Key B is  found");

else


  <PRINTLN>("The  Key B is not found");




üß© Detailed Explanation

üîë Key Features

‚Ä¢ 	Thread Safety ‚Üí Unlike , which is not synchronized,  ensures safe concurrent access.

‚Ä¢ 	Fine‚Äëgrained locking ‚Üí Instead of locking the whole map, it locks only portions (called segments in older versions, or bins in newer ones). This improves performance.

‚Ä¢ 	No nulls allowed ‚Üí It does not permit  keys or  values.

‚Ä¢ 	Atomic operations ‚Üí Provides methods like , , and  that execute atomically.

‚Ä¢ 	Performance ‚Üí Reads are usually lock‚Äëfree, and updates use minimal locking, making it faster than .

‚Ä¢ 	Default concurrency level ‚Üí Typically 16, meaning up to 16 threads can modify the map 

        concurrently without blocking each other.


üß© Step‚Äëby‚ÄëStep Explanation

Print a header

<PRINTLN>("------------------------------------------------------------------------------------"); 

<PRINTLN>(" J7Concurrent HashMap EXAMPLES "); 

<PRINTLN>("------------------------------------------------------------------------------------");

This simply prints a decorative banner to mark the start of the demonstration.

Create a concurrent hash map

OJ7Lib.J7ConcurrentHashMap map19 = new OJ7Lib.J7ConcurrentHashMap(16);

A new J7ConcurrentHashMap object is created with an initial capacity of 16. This is your custom concurrent map implementation.

Put and get a value

   map19.put("A", 1); (map19.get("A"));

Adds the key "A" with value 1.

Retrieves and prints the value for "A", which is 1.

Compute if absent

           map19 = map19.ComputeIfAbsent(map19, "B", "42"); (map19.get("B"));

If key "B" is not already present, it is added with the value "42".

Prints the value of "B", which becomes "42".

 Compute if present

map19 = map19.ComputeIfPresent(map19, "A", "46"); (map19.get("A"));

If key "A" exists, its value is updated to "46".

Prints the new value of "A", which is "46".

Merge values

map19 = map19.Merge(map19, "B", " ", 3); (map19.get("B"));

Merges the existing value of "B" with 3.

The logic in your Merge method adds integers, so "42" (if treated as a number) plus 3 becomes 45.

Prints the updated value of "B".


Visit all entries

map19 = map19.Visit(map19, "", ""); (map19.get("A"));

Iterates through all key‚Äìvalue pairs in the map and prints them.

Then prints the value of "A" again, which is "46".

Remove a key and check existence

map19.remove("B"); if (map19.get("B") NOT = null) ("The Key B is found"); else ("The Key B is not found");

Removes the key "B" from the map.

Checks if "B" still exists. Since it was removed, map19.get("B") returns null.

Prints: ‚ÄúThe Key B is not found‚Äù.


üìä Summary 

This program demonstrates how to use a J7ConcurrentHashMap by:

Adding and retrieving values (put, get).

Conditionally inserting (ComputeIfAbsent).

Conditionally updating (ComputeIfPresent).

Merging values (Merge).

Iterating over entries (Visit).

Removing a key and checking if it still exists (remove, get).

At the end, the program confirms that key "B" has been removed and is no longer found in the map.


üö® Key Considerations

Use ConcurrentHashMap when multiple threads need to update a shared map.

Avoid it if you need insertion order or sorted order (use ConcurrentSkipListMap instead).

Remember: it disallows null keys and values to prevent ambiguity in concurrent operations.

In short: ConcurrentHashMap is a high‚Äëperformance, thread‚Äësafe map designed for concurrent applications, 

making it ideal for caches, registries, and shared data structures in multi‚Äëthreaded systems.


‚ö° Expected Output (Simplified)


------------------------------------------------------------------------------------

                 J7Concurrent HashMap  EXAMPLES                          

------------------------------------------------------------------------------------

1

42

46

45

A -> 46

B -> 45

46

The  Key B is not found




Define  ArrayList

An ArrayList is a resizable array implementation provided in Java‚Äôs and Dotweb Collections Framework.and for Dotweb5.0 Util  package is  called as OJ7Lib It‚Äôs part of the  package and is widely used because it combines the simplicity of arrays with the flexibility of dynamic resizing.

üîë Key Characteristics of ArrayList


‚Ä¢ 	Dynamic size: Unlike arrays, which have a fixed length, an ArrayList can grow or shrink as elements are added or removed.

‚Ä¢ 	Indexed access: Elements can be accessed directly using their index (just like arrays).

‚Ä¢ 	Ordered collection: Maintains the order of insertion.

‚Ä¢ 	Allows duplicates: You can store duplicate elements.

‚Ä¢ 	Supports null values: Multiple  entries are allowed.

‚Ä¢ 	Not synchronized: By default, ArrayList is not thread-safe. For multi-threaded use, you‚Äôd need synchronization.


Program  for  J7Arraylist


<PRINTLN("------------------------------------------------------------------------------------");


<PRINTLN>("                 J7ARRAYLIST  EXAMPLES                          ");

<PRINTLN>("------------------------------------------------------------------------------------");



    // Create a J7ArrayList of Strings

        OJ7Lib.J7ArrayList names = new OJ7Lib.J7ArrayList();


        // Add elements

        names.add("Alice");

        names.add("Bob");

        names.add("Charlie");

        names.add("Diana");


        <PRINTLN>("Initial list:");

        foreach (String name in  names) {

            <PRINTLN>(name);

        }


        // Get element by index

        <PRINTLN>("\nElement at index 2: " + names.get(2));


        // Set element at index

        names.set(1, "Bobby");

        <PRINTLN>("\nAfter setting index 1 to 'Bobby':");

        foreach (String name in  names) {

            <PRINTLN>(name);

        }


        // Remove element by index

        names.remove(0);

        <PRINTLN>("\nAfter removing element at index 0:");

        foreach (String name in  names) {

            <PRINTLN>(name);

        }


        // Remove element by value

        names.remove("Charlie");

        <PRINTLN>("\nAfter removing 'Charlie':");

        foreach (String name in  names) {

            <PRINTLN>(name);

        }


        // Check contains

        <PRINTLN>("\nContains 'Diana'? " + names.contains("Diana"));

        <PRINTLN>("Contains 'Alice'? " + names.contains("Alice"));


        // Size

        <PRINTLN>("\nSize of list: " + names.size());


        // Clear

        names.clear();

        <PRINTLN>("\nAfter clear, isEmpty? " + names.isEmpty());


üìù Brief Explanation of the Program


This program demonstrates the use of OJ7Lib.J7ArrayList (similar to Java‚Äôs ArrayList) with basic operations:

Initialization

A new J7ArrayList of Strings is created to store names.

Adding Elements

Names like "Alice", "Bob", "Charlie", and "Diana" are added to the list.

Displaying Elements

A foreach loop prints all elements in the list.

Accessing by Index

names.get(2) retrieves the element at index 2 (Charlie).

Updating Elements

names.set(1, "Bobby") replaces "Bob" with "Bobby".

Removing Elements

names.remove(0) removes the first element (Alice).

names.remove("Charlie") removes the element by value.

Checking Existence

names.contains("Diana") returns true.

names.contains("Alice") returns false after removal.

Size of List

names.size() shows the number of elements currently in the list.

Clearing the List

names.clear() removes all elements.

names.isEmpty() confirms the list is empty.

üëâ Essentially, the program is a step-by-step demo of ArrayList operations: add, get, set, remove, contains, size, and clear.



‚ö° Expected Output (Simplified)



------------------------------------------------------------------------------------

                 J7ARRAYLIST  EXAMPLES                          

------------------------------------------------------------------------------------

Initial list:

Alice

Bob

Charlie

Diana


Element at index 2: Charlie


After setting index 1 to 'Bobby':

Alice

Bobby

Charlie

Diana


After removing element at index 0:

Bobby

Charlie

Diana


After removing 'Charlie':

Bobby

Diana


Contains 'Diana'? True

Contains 'Alice'? False


Size of list: 2
===============================================================================================


# üìò What is a Stack?

- A **stack** is a **linear data structure** that follows the **LIFO (Last In, First Out)** principle.  
- This means the **last element pushed** onto the stack will be the **first one popped** out.  
- Think of a stack of plates: you add plates on top, and you remove plates from the top.  

---

# üìù Definition of Stack

A **stack** is defined as a collection of elements with two primary operations:
- **PUSH** ‚Üí Adds an element to the top of the stack.  
- **POP** ‚Üí Removes the element from the top of the stack.  

Additional operations often include:
- **peek()** ‚Üí Views the top element without removing it.  
- **size()** ‚Üí Returns the number of elements in the stack.  
- **contains(x)** ‚Üí Checks if an element exists in the stack.  
- **removeElementAt(index)** ‚Üí Removes element at a specific position.  
- **removeAllElements()** ‚Üí Clears the stack completely.  

---

# ‚öôÔ∏è Dotweb5.0 Example Code Explained

Here‚Äôs your code, explained step by step:

```Dotweb5.0
OJ7Lib.<VList><STACK> st = new OJ7Lib.<VList><STACK>(9);
```
- Creates a stack object `st` with capacity `9`.

---

### 1. Pushing Elements
```Dotweb5.0
st.<PUSH>(1);
st.<PUSH>(2);
st.<PUSH>(3);
st.<PUSH>(4);
```
- Adds elements `1, 2, 3, 4` to the stack in order.  
- Current stack (top ‚Üí bottom): **4, 3, 2, 1**

---

### 2. Popping and Peeking
```Dotweb5.0
<PRINTLN>(st.<POP>);
<PRINTLN>(st.peek());
```
- `POP` removes the top element ‚Üí removes `4`.  
- `peek()` shows the new top element ‚Üí `3`.  

---

### 3. More Push Operations
```Dotweb5.0
st.<PUSH>(5);
st.<PUSH>(6);
```
- Adds `5` and `6`.  
- Current stack: **6, 5, 3, 2, 1**

---

### 4. Removing by Index
```Dotweb5.0
st.removeElementAt(0);
```
- Removes element at index `0` (bottom-most element ‚Üí `1`).  
- Current stack: **6, 5, 3, 2**

---

### 5. Adding More Elements
```Dotweb5.0
st.<PUSH>(7);
st.<PUSH>(8);
```
- Adds `7` and `8`.  
- Current stack: **8, 7, 6, 5, 3, 2**

---

### 6. Checking and Accessing
```Dotweb5.0
<PRINTLN>(st.contains(7));
<PRINTLN>(st.elementAt(0));
<PRINTLN>(st.size());
```
- `contains(7)` ‚Üí returns `true`.  
- `elementAt(0)` ‚Üí returns bottom-most element ‚Üí `2`.  
- `size()` ‚Üí returns number of elements ‚Üí `6`.

---

### 7. Removing All Elements
```Dotweb5.0
st.removeAllElements(st);
<PRINTLN>(st.size());
```
- Clears the stack completely.  
- `size()` ‚Üí returns `0`.


‚ú® Dotweb5.0 Stack Example

<PRINTLN>("------------------------------------------------------------------------------------");
<PRINTLN>("                 <STACK>   EXAMPLES                          ");
<PRINTLN>("------------------------------------------------------------------------------------");

OJ7Lib.<VList><STACK> st = new OJ7Lib.<VList><STACK>(9);

    // -------------------------------
    // Push elements onto the stack
    // -------------------------------
    st.<PUSH>(1);
    st.<PUSH>(2);
    st.<PUSH>(3);
    st.<PUSH>(4);

    // -------------------------------
    // Pop the top element and peek
    // -------------------------------
    <PRINTLN>(st.<POP>);
    <PRINTLN>(st.peek());

    // -------------------------------
    // Push more elements
    // -------------------------------
    st.<PUSH>(5);
    st.<PUSH>(6);

    // -------------------------------
    // Remove element at index 0
    // -------------------------------
    st.removeElementAt(0);

    // -------------------------------
    // Push additional elements
    // -------------------------------
    st.<PUSH>(7);
    st.<PUSH>(8);

    // -------------------------------
    // Check contents and properties
    // -------------------------------
    <PRINTLN>(st.contains(7));
    <PRINTLN>(st.elementAt(0));
    <PRINTLN>(st.size());

    // -------------------------------
    // Remove all elements
    // -------------------------------
    st.removeAllElements(st);
    <PRINTLN>(st.size());

---

# ‚úÖ Final Output (Step by Step)

```
4   // POP result
3   // peek result
true // contains(7)
2    // elementAt(0)
6    // size before clearing
0    // size after clearing
```

---

# üéØ Conclusion

- The **Dotweb5.0 stack code** demonstrates all major stack operations: **push, pop, peek, contains, elementAt, size, removeElementAt, removeAllElements**.  
- It shows how a stack maintains **LIFO order** while still allowing extra operations like removing by index or clearing all elements. 

  =================================================================0

# üìò What is a Queue?

- A **queue** is a **linear data structure** that follows the **FIFO (First In, First Out)** principle.  
- This means the **first element inserted** into the queue will be the **first one removed**.  
- Think of a line at a ticket counter: the person who comes first is served first.  

---

# üìù Definition of Queue

A **queue** is defined as a collection of elements with two primary operations:
- **enqueue** ‚Üí Adds an element to the rear (end) of the queue.  
- **dequeue** ‚Üí Removes the element from the front of the queue.  

Additional operations often include:
- **peek()** ‚Üí Views the front element without removing it.  
- **size()** ‚Üí Returns the number of elements in the queue.  
- **display()** ‚Üí Shows all elements in the queue.  

---

# ‚öôÔ∏è Dotweb5.0 LinkedQueue Example Code Explained

Here‚Äôs your code, explained step by step:

```Dotweb5.0
OJ7Lib.LinkedListQueue q3 = new OJ7Lib.LinkedListQueue();
```
- Creates a new **LinkedQueue object** `q3`.

---

### 1. Enqueue Operations
```Dotweb5.0
q3.enqueue(10);
q3.enqueue(20);
q3.enqueue(30);
q3.enqueue(40);
```
- Adds elements `10, 20, 30, 40` to the queue in order.  
- Current queue (front ‚Üí rear): **10, 20, 30, 40**

---

### 2. Display Queue
```Dotweb5.0
q3.display();
```
- Prints all elements in the queue.  
- Output: `10 20 30 40`

---

### 3. Peek Front Element
```Dotweb5.0
<PRINTLN>("Front element: " + q3.peek());
```
- Shows the front element without removing it.  
- Output: `Front element: 10`

---

### 4. Dequeue Operation
```Dotweb5.0
q3.dequeue();
```
- Removes the front element (`10`).  
- Current queue: **20, 30, 40**

---

### 5. Display Queue Again
```Dotweb5.0
q3.display();
```
- Prints the updated queue.  
- Output: `20 30 40`

---

### 6. Queue Size
```Dotweb5.0
<PRINTLN>("Queue size: " + q3.size());
```
- Returns the number of elements in the queue.  
- Output: `Queue size: 3`

---

‚ú® Dotweb5.0 LinkedQueue example code

<PRINTLN>("------------------------------------------------------------------------------------");
<PRINTLN>("                 LinkedQueue  EXAMPLES                          ");
<PRINTLN>("------------------------------------------------------------------------------------");

OJ7Lib.LinkedListQueue q3 = new OJ7Lib.LinkedListQueue();

    // -------------------------------
    // Enqueue elements into the queue
    // -------------------------------
    q3.enqueue(10);
    q3.enqueue(20);
    q3.enqueue(30);
    q3.enqueue(40);

    // -------------------------------
    // Display current queue
    // -------------------------------
    q3.display();

    // -------------------------------
    // Peek at the front element
    // -------------------------------
    <PRINTLN>("Front element: " + q3.peek());

    // -------------------------------
    // Dequeue one element
    // -------------------------------
    q3.dequeue();

    // -------------------------------
    // Display updated queue
    // -------------------------------
    q3.display();

    // -------------------------------
    // Show current size
    // -------------------------------
    <PRINTLN>("Queue size: " + q3.size());


# ‚úÖ Final Output (Step by Step)

------------------------------------------------------------------------------------
                 LinkedQueue  EXAMPLES                          
------------------------------------------------------------------------------------
10 20 30 40
Front element: 10
20 30 40
Queue size: 3
```

---

# üéØ Conclusion

- The **LinkedQueue example** demonstrates the **FIFO principle** clearly.  
- Operations shown: **enqueue, dequeue, peek, display, size**.  
- It highlights how a queue differs from a stack:  
  - **Stack ‚Üí LIFO (last in, first out)**  
  - **Queue ‚Üí FIFO (first in, first out)**  

---

# üìò Stack vs LinkedQueue

## üîë Core Principle
- **Stack** ‚Üí **LIFO (Last In, First Out)**  
  - The last element pushed is the first one popped.  
- **LinkedQueue** ‚Üí **FIFO (First In, First Out)**  
  - The first element enqueued is the first one dequeued.  

---

## ‚öôÔ∏è Operations

| Operation | Stack | LinkedQueue |
|-----------|-------|-------------|
| **Insert** | `push()` ‚Üí adds element to the **top** | `enqueue()` ‚Üí adds element to the **rear** |
| **Remove** | `pop()` ‚Üí removes element from the **top** | `dequeue()` ‚Üí removes element from the **front** |
| **Peek** | `peek()` ‚Üí views the **top** element | `peek()` ‚Üí views the **front** element |
| **Traversal** | From top to bottom | From front to rear |

---

## üìä Behavior Example

### Stack (LIFO)
```Dotweb5.0
Stack s = new Stack();
s.push(1);
s.push(2);
s.push(3);
System.out.println(s.pop()); // 3
```
- Output: `3` (last in, first out)

### LinkedQueue (FIFO)
```Dotweb5.0
LinkedQueue q = new LinkedQueue();
q.enqueue(1);
q.enqueue(2);
q.enqueue(3);
System.out.println(q.dequeue()); // 1
```
- Output: `1` (first in, first out)

---

## üèóÔ∏è Implementation
- **Stack**: Can be implemented using arrays or linked lists.  
- **LinkedQueue**: Typically implemented using linked lists (nodes with pointers to next).  

---

## üìå Use Cases
- **Stack**:  
  - Undo/Redo functionality  
  - Expression evaluation (postfix/prefix)  
  - Backtracking algorithms  

- **LinkedQueue**:  
  - Scheduling tasks  
  - Order processing systems  
  - Breadth-first search (BFS) in graphs  

---

# üéØ Conclusion
- **Stack** is about handling the **latest item first** (LIFO).  
- **LinkedQueue** is about handling the **earliest item first** (FIFO).  
- Both are fundamental data structures but serve **different logical needs** in programming.  
===============================================================================================


---

# üìò What is J7Queue?

- **J7Queue** is a queue implementation provided in the Dotweb5.0 library (`OJ7Lib`).  
- It follows the **FIFO (First In, First Out)** principle: the first element inserted is the first one removed.  
- It supports standard queue operations such as **enqueue, dequeue, peek, size, and isEmpty**.  

---

# üìù Definition of Queue (J7Queue)

A **queue** is a linear data structure with these operations:
- **enqueue(x)** ‚Üí Adds element `x` to the rear of the queue.  
- **dequeue() / j7dequeue()** ‚Üí Removes the front element.  
- **peek()** ‚Üí Views the front element without removing it.  
- **size()** ‚Üí Returns the number of elements in the queue.  
- **isEmpty()** ‚Üí Checks if the queue has no elements.  

---

# ‚öôÔ∏è Dotweb5.0 J7Queue Example Code Explained

Here‚Äôs the code, explained step by step:

```Dotweb5.0
OJ7Lib.J7Queue q = new OJ7Lib.J7Queue(5);
```
- Creates a **J7Queue object** `q` with capacity `5`.

---

### 1. Enqueue Operations
```Dotweb5.0
q.enqueue(1);
q.enqueue(2);
q.enqueue(3);
q.enqueue(4);
```
- Adds elements `1, 2, 3, 4` to the queue.  
- Current queue (front ‚Üí rear): **1, 2, 3, 4**

---

### 2. Peek Front Element
```Dotweb5.0
<PRINTLN>("Front element is: " + q.peek());
```
- Shows the front element without removing it.  
- Output: `Front element is: 1`

---

### 3. Dequeue Operation
```Dotweb5.0
q.j7dequeue();
<PRINTLN>("Front element is: " + q.peek());
```
- Removes the front element (`1`).  
- New front element is `2`.  
- Output: `Front element is: 2`

---

### 4. Queue Size
```Dotweb5.0
<PRINTLN>("Queue size is " + q.size());
```
- Returns the number of elements currently in the queue.  
- Output: `Queue size is 3`

---

### 5. Multiple Dequeues
```Dotweb5.0
q.j7dequeue();
q.j7dequeue();
q.j7dequeue();
```
- Removes `2, 3, 4` sequentially.  
- Queue becomes empty.

---

### 6. Enqueue Again
```Dotweb5.0
q.enqueue(1123);
<PRINTLN>("Front element is: " + q.peek());
```
- Adds `1123` to the queue.  
- Front element is now `1123`.  
- Output: `Front element is: 1123`

---

### 7. Check Empty Status
```Dotweb5.0
if (q.isEmpty())
    <PRINTLN>("Queue is empty");
else
    <PRINTLN>("Queue is not empty");
```
- Since `1123` is present, the queue is **not empty**.  
- Output: `Queue is not empty`
---
‚ú® J7Queue Example Code

// -----------------------------------------------------------------------------
//                          J7Queue EXAMPLES
// -----------------------------------------------------------------------------

<PRINTLN>("------------------------------------------------------------------------------------");
<PRINTLN>("                 J7Queue  EXAMPLES                          ");
<PRINTLN>("------------------------------------------------------------------------------------");

OJ7Lib.J7Queue q = new OJ7Lib.J7Queue(5);

    // -------------------------------
    // Enqueue elements into the queue
    // -------------------------------
    q.enqueue(1);
    q.enqueue(2);
    q.enqueue(3);
    q.enqueue(4);

    <PRINTLN>("Front element is: " + q.peek());

    // -------------------------------
    // Dequeue one element
    // -------------------------------
    q.j7dequeue();
    <PRINTLN>("Front element is: " + q.peek());

    // -------------------------------
    // Show current size
    // -------------------------------
    <PRINTLN>("Queue size is: " + q.size());

    // -------------------------------
    // Remove all remaining elements
    // -------------------------------
    q.j7dequeue();
    q.j7dequeue();
    q.j7dequeue();

    // -------------------------------
    // Enqueue a new element
    // -------------------------------
    q.enqueue(1123);
    <PRINTLN>("Front element is: " + q.peek());

    // -------------------------------
    // Check if queue is empty
    // -------------------------------
    if (q.isEmpty())
        <PRINTLN>("Queue is empty");
    else
        <PRINTLN>("Queue is not empty");

# ‚úÖ Final Output (Step by Step)

```
------------------------------------------------------------------------------------
                 J7Queue  EXAMPLES                          
------------------------------------------------------------------------------------
Front element is: 1
Front element is: 2
Queue size is 3
Front element is: 1123
Queue is not empty
```

---

# üéØ Conclusion

- The **J7Queue example** demonstrates the **FIFO principle** clearly.  
- Operations shown: **enqueue, dequeue, peek, size, isEmpty**.  
- It highlights how J7Queue manages elements in order, ensuring the earliest enqueued item is always served first.  

---

===============================================================================================


---

# üìò What is a J7Hashtable?

- A **J7Hashtable** is a data structure that stores elements in **key‚Äìvalue pairs**.  
- It uses **hashing** to compute an index into an array of buckets, from which the desired value can be found.  
- Keys are unique, and each key maps to exactly one value.  
- It provides **fast access (average O(1))** for insertion, deletion, and lookup.  

---

# üìù Definition of J7Hashtable

A **Hashtable** is defined as:  
- A collection of **key-value pairs**.  
- **put(key, value)** ‚Üí Inserts a mapping into the table.  
- **get(key)** ‚Üí Retrieves the value for a given key.  
- **containsKey(key)** ‚Üí Checks if a key exists.  
- **containsValue(value)** ‚Üí Checks if a value exists.  
- **remove(key)** ‚Üí Removes a key-value pair.  
- **size()** ‚Üí Returns the number of entries.  
- **clear()** ‚Üí Removes all entries.  
- **clone()** ‚Üí Creates a shallow copy of the hashtable.  
- **equals()** ‚Üí Compares two hashtables for equality.  

---

# ‚öôÔ∏è Dotweb5.0 J7Hashtable Example Code Explained

```
<PRINTLN>("-------------------------------------------------------");
<PRINTLN>("              HASHTABLE                              ");
<PRINTLN>("-------------------------------------------------------");

OJ7Lib.J7HashTable table = new OJ7Lib.J7HashTable();
```
- Creates a new **J7HashTable object** named `table`.

---

### 1. Insert Key-Value Pairs
```
table.put("Apple", 10);
table.put("Banana", 20);
table.put("Cherry", 30);
```
- Adds three entries:  
  - `"Apple" ‚Üí 10`  
  - `"Banana" ‚Üí 20`  
  - `"Cherry" ‚Üí 30`

---

### 2. Check for Key
```
<PRINTLN>("Contains key 'Banana'? " + table.containsKey("Banana"));
```
- Checks if `"Banana"` exists.  
- Output: `Contains key 'Banana'? true`

---

### 3. Check for Value
```
<PRINTLN>("Contains value 30? " + table.containsValue(30));
```
- Checks if value `30` exists.  
- Output: `Contains value 30? true`

---

### 4. Clone the Hashtable
```
OJ7Lib.J7HashTable copy = table.clone();
<PRINTLN>("Clone contains key 'Apple'? " + copy.containsKey("Apple"));
```
- Creates a copy of the hashtable.  
- Checks if `"Apple"` exists in the clone.  
- Output: `Clone contains key 'Apple'? true`

---

### 5. Compare Equality
```
<PRINTLN>("Table equals copy? " + table.equals(copy));
```
- Compares `table` and `copy`.  
- Output: `Table equals copy? true`

---

### 6. Clear the Hashtable
```
table.clear();
<PRINTLN>("Size after clear: " + table.size());
```
- Removes all entries from `table`.  
- Output: `Size after clear: 0`

‚ú® Dotweb5.0 J7HashTable Example

<PRINTLN>("-------------------------------------------------------");
<PRINTLN>("                   HASHTABLE                           ");
<PRINTLN>("-------------------------------------------------------");

OJ7Lib.J7HashTable table = new OJ7Lib.J7HashTable();

    // -------------------------------
    // Insert key-value pairs
    // -------------------------------
    table.put("Apple", 10);
    table.put("Banana", 20);
    table.put("Cherry", 30);

    // -------------------------------
    // containsKey()
    // -------------------------------
    <PRINTLN>("Contains key 'Banana'? " + table.containsKey("Banana")); // true

    // -------------------------------
    // containsValue()
    // -------------------------------
    <PRINTLN>("Contains value 30? " + table.containsValue(30)); // true

    // -------------------------------
    // clone()
    // -------------------------------
    OJ7Lib.J7HashTable copy = table.clone();
    <PRINTLN>("Clone contains key 'Apple'? " + copy.containsKey("Apple")); // true

    // -------------------------------
    // equals()
    // -------------------------------
    <PRINTLN>("Table equals copy? " + table.equals(copy)); // true

    // -------------------------------
    // clear()
    // -------------------------------
    table.clear();
    <PRINTLN>("Size after clear: " + table.size()); // 0

---

# ‚úÖ Final Output (Step by Step)

```
-------------------------------------------------------
              HASHTABLE                              
-------------------------------------------------------
Contains key 'Banana'? true
Contains value 30? true
Clone contains key 'Apple'? true
Table equals copy? true
Size after clear: 0
```

---

# üéØ Conclusion

- The **J7Hashtable program** demonstrates key operations: **put, containsKey, containsValue, clone, equals, clear, size**.  
- It shows how a hashtable manages **fast lookups** using keys and supports cloning and equality checks.  
- After clearing, the table becomes empty, confirming the **dynamic nature** of hashtables.  
==============================================================================================


---

# üìò What is a TreeSet?

- A **TreeSet** is a **sorted set** that stores unique elements in **ascending or descending order**.  
- It is typically backed by a **balanced binary search tree**, ensuring efficient operations.  
- It automatically maintains **order** and prevents duplicates.  

---

# üìù Definition of TreeSet

A **TreeSet** supports:  
- **add(x)** ‚Üí Insert element `x`.  
- **ASCDisplay() / DESCDisplay()** ‚Üí Show elements in ascending or descending order.  
- **higher(x)** ‚Üí Returns the least element strictly greater than `x`.  
- **lower(x)** ‚Üí Returns the greatest element strictly less than `x`.  
- **highest() / lowest()** ‚Üí Returns maximum or minimum element.  
- **pollFirst() / pollLast()** ‚Üí Removes and returns the first or last element.  
- **contains(x)** ‚Üí Checks if an element exists.  
- **removeall()** ‚Üí Clears all elements.  

---

# ‚öôÔ∏è Dotweb5.0 TreeSet Program Explained

```
<PRINTLN>("-------------------------------------------------------");
<PRINTLN>("                 TREE SET  DETAILS                     ");
<PRINTLN>("-------------------------------------------------------");

// Create TreeSet with ASC order (Strings)
OJ7Lib.TreeSet treeset = new OJ7Lib.TreeSet("ASC");
    treeset.add("minister");
    treeset.add("master");
    treeset.add("cad");
    treeset.add("phd");

// Create TreeSet with capacity (Integers)
OJ7Lib.TreeSet treeset1 = new OJ7Lib.TreeSet(5);
    treeset1.add(13);
    treeset1.add(15);
    treeset1.add(12);
    treeset1.add(1);

// Display elements in ASC order
<PRINTLN>("ASC: " + treeset1.ASCDisplay());

// Find higher and lower elements
<PRINTLN>("higher= " + treeset1.higher(13));
<PRINTLN>("lower= " + treeset1.lower(17));

// Find highest and lowest elements
<PRINTLN>("last= " + treeset1.highest());
<PRINTLN>("first= " + treeset1.lowest());

// Poll first and last elements
<PRINTLN>("PollFirst= " + treeset1.pollFirst());
<PRINTLN>("PollLast= " + treeset1.pollLast());

// Display elements in DESC order
<PRINTLN>("DESC: " + treeset1.DESCDisplay());

// Check if element exists
<PRINTLN>("Contains 151? " + treeset1.list.contains(151));

// Remove all elements
treeset1.removeall();
<PRINTLN>("After removeAll: " + treeset1.list.isEmpty());
```

---

# ‚úÖ Step‚Äëby‚ÄëStep Explanation

1. **Create TreeSet (Strings)**  
   - Stores `"minister"`, `"master"`, `"cad"`, `"phd"` in ascending order.  

2. **Create TreeSet (Integers)**  
   - Stores `13, 15, 12, 1`.  

3. **ASCDisplay()**  
   - Shows elements sorted ascending ‚Üí `[1, 12, 13, 15]`.  

4. **higher(13)**  
   - Finds the next greater element after `13` ‚Üí `15`.  

5. **lower(17)**  
   - Finds the greatest element less than `17` ‚Üí `15`.  

6. **highest() / lowest()**  
   - Highest element ‚Üí `15`.  
   - Lowest element ‚Üí `1`.  

7. **pollFirst() / pollLast()**  
   - Removes and returns first (`1`) and last (`15`).  

8. **DESCDisplay()**  
   - Shows remaining elements in descending order ‚Üí `[13, 12]`.  

9. **contains(151)**  
   - Checks if `151` exists ‚Üí `false`.  

10. **removeall()**  
    - Clears all elements.  
    - `isEmpty()` ‚Üí `true`.  

---

# üéØ Final Output (Step by Step)

```
-------------------------------------------------------
                 TREE SET  DETAILS                     
-------------------------------------------------------
ASC: [1, 12, 13, 15]
higher= 15
lower= 15
last= 15
first= 1
PollFirst= 1
PollLast= 15
DESC: [13, 12]
Contains 151? false
After removeAll: true
```
=================================================================================================

# üìò What is a TreeMap?

- A **TreeMap** is a **map data structure** that stores key‚Äìvalue pairs in **sorted order of keys**.  
- It is typically implemented using a **Red-Black Tree** (balanced binary search tree).  
- Keys are unique, and each key maps to exactly one value.  
- Provides efficient operations: **put, get, remove, containsKey, containsValue, subMap, headMap, tailMap**.  

---

# üìù Definition of TreeMap

A **TreeMap** supports:  
- **put(key, value)** ‚Üí Insert a key-value pair.  
- **get(key)** ‚Üí Retrieve value for a given key.  
- **containsKey(key)** ‚Üí Check if a key exists.  
- **containsValue(value)** ‚Üí Check if a value exists.  
- **remove(key)** ‚Üí Remove a key-value pair.  
- **size() / isEmpty()** ‚Üí Get number of entries or check if empty.  
- **keySet() / values()** ‚Üí Get all keys or values.  
- **subMap(from, to)** ‚Üí Get a portion of the map between two keys.  
- **headMap(toKey)** ‚Üí Get all entries with keys less than `toKey`.  
- **tailMap(fromKey)** ‚Üí Get all entries with keys greater than or equal to `fromKey`.  
- **clear()** ‚Üí Remove all entries.  

---

# ‚ú® Dotweb5.0 TreeMap Example

```
<PRINTLN>("-------------------------------------------------------");
<PRINTLN>("                   TREEMAP                             ");
<PRINTLN>("-------------------------------------------------------");

// -------------------------------
// Create a TreeMap (keys sorted in natural order)
// -------------------------------
OJ7Lib.TreeMap map = new OJ7Lib.TreeMap();

// -------------------------------
// put() - Insert key-value pairs
// -------------------------------
map.put(3, "Three");
map.put(1, "One");
map.put(2, "Two");
map.put(5, "Five");
<PRINTLN>("After put: " + map);

// -------------------------------
// get()
// -------------------------------
<PRINTLN>("Get key 2: " + map.get(2));

// -------------------------------
// containsKey() and containsValue()
// -------------------------------
<PRINTLN>("Contains key 3? " + map.containsKey(3));
<PRINTLN>("Contains value 'Five'? " + map.containsValue("Five"));

// -------------------------------
// remove()
// -------------------------------
map.remove(3);
<PRINTLN>("After remove key 3: " + map);

// -------------------------------
// size() and isEmpty()
// -------------------------------
<PRINTLN>("Size: " + map.size());
<PRINTLN>("Is empty? " + map.isEmpty());

// -------------------------------
// keySet() and values()
// -------------------------------
<PRINTLN>("Key set: " + map.keySet());
<PRINTLN>("Values: " + map.values());

// -------------------------------
// subMap(), headMap(), tailMap()
// -------------------------------
<OJ7UTIL>.SortedMap sub = map.subMap(1, 5);
<PRINTLN>("SubMap(1,5): " + sub);

<OJ7UTIL>.SortedMap head = map.headMap(3);
<PRINTLN>("HeadMap(<3): " + head);

<OJ7UTIL>.SortedMap tail = map.tailMap(2);
<PRINTLN>("TailMap(>=2): " + tail);

// -------------------------------
// clear()
// -------------------------------
map.clear();
<PRINTLN>("After clear: " + map);
```

---

# ‚úÖ Step‚Äëby‚ÄëStep Explanation

1. **Create TreeMap** ‚Üí Keys will be stored in natural ascending order.  
2. **put()** ‚Üí Adds entries: `{1=One, 2=Two, 3=Three, 5=Five}`.  
3. **get(2)** ‚Üí Retrieves `"Two"`.  
4. **containsKey(3)** ‚Üí Returns `true`.  
5. **containsValue("Five")** ‚Üí Returns `true`.  
6. **remove(3)** ‚Üí Removes key `3`. Map becomes `{1=One, 2=Two, 5=Five}`.  
7. **size() / isEmpty()** ‚Üí Size is `3`, not empty.  
8. **keySet() / values()** ‚Üí Keys ‚Üí `[1, 2, 5]`, Values ‚Üí `[One, Two, Five]`.  
9. **subMap(1,5)** ‚Üí Returns `{1=One, 2=Two}` (keys between 1 and 5).  
10. **headMap(3)** ‚Üí Returns `{1=One, 2=Two}` (keys less than 3).  
11. **tailMap(2)** ‚Üí Returns `{2=Two, 5=Five}` (keys ‚â• 2).  
12. **clear()** ‚Üí Removes all entries. Map becomes `{}`.  

---

# üéØ Final Output (Step by Step)

```
-------------------------------------------------------
                   TREEMAP                             
-------------------------------------------------------
After put: {1=One, 2=Two, 3=Three, 5=Five}
Get key 2: Two
Contains key 3? true
Contains value 'Five'? true
After remove key 3: {1=One, 2=Two, 5=Five}
Size: 3
Is empty? false
Key set: [1, 2, 5]
Values: [One, Two, Five]
SubMap(1,5): {1=One, 2=Two}
HeadMap(<3): {1=One, 2=Two}
TailMap(>=2): {2=Two, 5=Five}
After clear: {}
```


# üìò TreeMap vs TreeSet

Both **TreeMap** and **TreeSet** are part of the **sorted collections** family, but they serve different purposes. Let‚Äôs break them down clearly.

---

## üîë Core Difference

- **TreeSet** ‚Üí Stores **unique elements** in **sorted order**.  
- **TreeMap** ‚Üí Stores **key‚Äìvalue pairs** with **keys sorted** in natural order.  

---

## ‚öôÔ∏è Operations Comparison

| Feature / Operation | **TreeSet** | **TreeMap** |
|----------------------|-------------|-------------|
| **Data Stored** | Only **elements** (no duplicates) | **Key‚ÄìValue pairs** |
| **Ordering** | Elements sorted (ASC/DESC) | Keys sorted (ASC by default) |
| **Insertion** | `add(element)` | `put(key, value)` |
| **Access** | `higher(x), lower(x), pollFirst(), pollLast()` | `get(key), subMap(), headMap(), tailMap()` |
| **Check Existence** | `contains(element)` | `containsKey(key), containsValue(value)` |
| **Remove** | `remove(element), removeall()` | `remove(key), clear()` |
| **Traversal** | ASCDisplay(), DESCDisplay() | keySet(), values() |

---

## üìä Example Flow

### TreeSet Example
```
OJ7Lib.TreeSet ts = new OJ7Lib.TreeSet("ASC");
ts.add(10);
ts.add(5);
ts.add(20);

<PRINTLN>("ASC: " + ts.ASCDisplay());   // [5, 10, 20]
<PRINTLN>("PollFirst: " + ts.pollFirst()); // 5
<PRINTLN>("DESC: " + ts.DESCDisplay());   // [20, 10]
```

### TreeMap Example
```
OJ7Lib.TreeMap map = new OJ7Lib.TreeMap();
map.put(3, "Three");
map.put(1, "One");
map.put(2, "Two");

<PRINTLN>("Map: " + map);              // {1=One, 2=Two, 3=Three}
<PRINTLN>("Get key 2: " + map.get(2)); // Two
<PRINTLN>("SubMap(1,3): " + map.subMap(1,3)); // {1=One, 2=Two}
```

---

## üéØ Use Cases

- **TreeSet**  
  - When you need a **sorted list of unique elements**.  
  - Useful for ranking, maintaining ordered sets, or removing duplicates automatically.  

- **TreeMap**  
  - When you need a **dictionary-like structure** with **sorted keys**.  
  - Useful for indexing, lookup tables, and range queries (subMap, headMap, tailMap).  

---

# ‚úÖ Conclusion

- **TreeSet** ‚Üí Best for **unique sorted elements**.  
- **TreeMap** ‚Üí Best for **sorted key‚Äìvalue mappings**.  
- Both rely on **tree-based structures** to maintain order and provide efficient operations.  

---


===============================================================================================

---

# üìò What is a Dictionary?

- A **Dictionary** is a data structure that stores **key‚Äìvalue pairs**.  
- Each **key** is unique and maps to a **value**.  
- It allows fast lookups, insertions, and deletions.  
- In Dotweb5.0, `Dictionary` is often implemented using a **Hashtable**.  

---

# üìù Definition of Dictionary

A **Dictionary** supports:  
- **put(key, value)** ‚Üí Insert a key-value pair.  
- **get(key)** ‚Üí Retrieve value for a given key.  
- **isEmpty()** ‚Üí Check if dictionary has no entries.  
- **keys()** ‚Üí Get all keys.  
- **elements()** ‚Üí Get all values.  
- **remove(key)** ‚Üí Remove a key-value pair.  
- **size()** ‚Üí Return the number of entries.  

---

# ‚ú® Dotweb5.0 Dictionary Example

```
<PRINTLN>("-------------------------------------------------------");
<PRINTLN>("                   Dictionary                          ");
<PRINTLN>("-------------------------------------------------------");

Dictionary mp = new Hashtable();

// -------------------------------
// put() - Insert key-value pairs
// -------------------------------
mp.put("279", "maths");
mp.put("56", "science");

// -------------------------------
// elements() - Display all values
// -------------------------------
for (Enumeration i = mp.elements(); i.hasMoreElements();) {
    <PRINTLN>("Value in Dictionary : " + i.nextElement());
}

// -------------------------------
// get() - Retrieve values by key
// -------------------------------
<PRINTLN>("\nValue at key = 6 : " + mp.get("6"));
<PRINTLN>("Value at key = 279 : " + mp.get("279"));

// -------------------------------
// isEmpty() - Check if dictionary is empty
// -------------------------------
<PRINTLN>("\nThere is no key-value pair : " + mp.isEmpty() + "\n");

// -------------------------------
// keys() - Display all keys
// -------------------------------
for (Enumeration k = mp.keys(); k.hasMoreElements();) {
    <PRINTLN>("Keys in Dictionary : " + k.nextElement());
}

// -------------------------------
// remove() - Remove a key-value pair
// -------------------------------
<PRINTLN>("\nRemove : " + mp.remove("279"));
<PRINTLN>("Check the value of removed key : " + mp.get("279"));

// -------------------------------
// size() - Get dictionary size
// -------------------------------
<PRINTLN>("\nSize of Dictionary : " + mp.size());
```

---

# ‚úÖ Step‚Äëby‚ÄëStep Explanation

1. **Create Dictionary** ‚Üí Backed by a Hashtable.  
2. **put()** ‚Üí Adds entries:  
   - `"279" ‚Üí "maths"`  
   - `"56" ‚Üí "science"`  
3. **elements()** ‚Üí Iterates through values ‚Üí prints `"maths"`, `"science"`.  
4. **get()** ‚Üí  
   - Key `"6"` ‚Üí returns `null` (not found).  
   - Key `"279"` ‚Üí returns `"maths"`.  
5. **isEmpty()** ‚Üí Returns `false` (dictionary has entries).  
6. **keys()** ‚Üí Iterates through keys ‚Üí prints `"279"`, `"56"`.  
7. **remove("279")** ‚Üí Removes key `"279"`.  
   - Checking again ‚Üí `null`.  
8. **size()** ‚Üí Returns `1` (only `"56" ‚Üí "science"` remains).  

---

# üéØ Final Output (Step by Step)

```
-------------------------------------------------------
                   Dictionary                          
-------------------------------------------------------
Value in Dictionary : maths
Value in Dictionary : science

Value at key = 6 : 
Value at key = 279 : maths

There is no key-value pair : false

Keys in Dictionary : 279
Keys in Dictionary : 56

Remove : maths
Check the value of removed key :  

Size of Dictionary : 1
```

---

# üìò Dictionary vs Hashtable

Both **Dictionary** and **Hashtable** are key‚Äìvalue pair data structures, but they differ in usage and implementation.  

---

## üîë Core Difference

- **Dictionary** ‚Üí Abstract class that defines the framework for key‚Äìvalue mappings.  
- **Hashtable** ‚Üí Concrete implementation of Dictionary that actually stores the data.  

---

## ‚öôÔ∏è Operations Comparison

| Feature / Operation | **Dictionary** | **Hashtable** |
|----------------------|----------------|---------------|
| **Type** | Abstract class | Concrete class |
| **Data Stored** | Key‚ÄìValue pairs | Key‚ÄìValue pairs |
| **Insertion** | `put(key, value)` | `put(key, value)` |
| **Access** | `get(key)` | `get(key)` |
| **Check Existence** | `isEmpty(), keys(), elements()` | `containsKey(), containsValue()` |
| **Remove** | `remove(key)` | `remove(key)` |
| **Traversal** | `keys(), elements()` | `keySet(), values(), entrySet()` |
| **Implementation** | Defines methods only | Provides actual working implementation |

---

## üìä Example Flow

### Dictionary Example (Dotweb5.0)
```
Dictionary mp = new Hashtable();
mp.put("279", "maths");
mp.put("56", "science");

<PRINTLN>("Value at key 279: " + mp.get("279"));   // maths
<PRINTLN>("Is empty? " + mp.isEmpty());            // false
```

### Hashtable Example (Dotweb5.0)
```
OJ7Lib.J7HashTable table = new OJ7Lib.J7HashTable();
table.put("Apple", 10);
table.put("Banana", 20);

<PRINTLN>("Contains key 'Banana'? " + table.containsKey("Banana")); // true
<PRINTLN>("Size: " + table.size());                                // 2
```

---

## üéØ Use Cases

- **Dictionary**  
  - Used as a **base class** for defining key‚Äìvalue structures.  
  - Provides **general methods** but not direct implementation.  

- **Hashtable**  
  - Used when you need a **working implementation** of Dictionary.  
  - Provides **fast lookups** and supports cloning, equality checks, and clearing.  

---

# ‚úÖ Conclusion

- **Dictionary** ‚Üí Abstract blueprint for key‚Äìvalue mappings.  
- **Hashtable** ‚Üí Concrete implementation that actually stores and manages key‚Äìvalue pairs.  
- In Dotweb5.0, you often **declare Dictionary but instantiate Hashtable**, combining both.  




===============================================================================================

---

# üìò What is a HashSet?

- A **HashSet** is a collection that stores **unique elements**.  
- It is backed by a **hash table**, which ensures fast insertion, deletion, and lookup.  
- Unlike lists, it does **not allow duplicates**.  
- Elements are **unordered** (no guaranteed sequence).  

---

# üìù Definition of HashSet

A **HashSet** supports:  
- **addItem(x)** ‚Üí Adds element `x` (ignores duplicates).  
- **removeItem(x)** ‚Üí Removes element `x`.  
- **ListItems()** ‚Üí Displays all elements.  
- **size()** ‚Üí Returns number of elements.  
- **isEmpty()** ‚Üí Checks if set is empty.  
- **Contains(x)** ‚Üí Checks if element exists.  
- **Clear()** ‚Üí Removes all elements.  

---

# ‚ú® Dotweb5.0 HashSet Example

```
<PRINTLN>("------------------------------------------------------------------------------------");
<PRINTLN>("                  HASH SET  EXAMPLES                          ");
<PRINTLN>("------------------------------------------------------------------------------------");

// -------------------------------
// Create HashSet and add elements
// -------------------------------
OJ7Lib.HashSet hashset = new OJ7Lib.HashSet(11);
    hashset.addItem("ac");
    hashset.addItem(51);
    hashset.addItem(5);
    hashset.addItem(5);   // duplicate ignored

// -------------------------------
// Display elements
// -------------------------------
<PRINTLN>(hashset.ListItems());

// -------------------------------
// Remove an element
// -------------------------------
<PRINTLN>(hashset.removeItem("ac"));
<PRINTLN>(hashset.ListItems());

// -------------------------------
// Show size and check empty
// -------------------------------
<PRINTLN>(hashset.size());
<PRINTLN>(hashset.isEmpty());

<PRINTLN>("**************");

// -------------------------------
// Create another HashSet and add elements
// -------------------------------
OJ7Lib.HashSet hs = new OJ7Lib.HashSet(11);
    hs.addItem("Geek");
    hs.addItem("For");
    hs.addItem("Geeks");
    hs.addItem("A");
    hs.addItem("B");
    hs.addItem("Z");

// -------------------------------
// Display elements
// -------------------------------
<PRINTLN>(hs.ListItems());

// -------------------------------
// Remove an element
// -------------------------------
hs.removeItem("B");
<PRINTLN>(hs.ListItems());
<PRINTLN>(hs.size());

<PRINTLN>("**************");

// -------------------------------
// Check existence and clear set
// -------------------------------
<PRINTLN>(hs.Contains("For"));
<PRINTLN>(hs.isEmpty());
hs.Clear();

// -------------------------------
// Verify after clear
// -------------------------------
<PRINTLN>(hs.Contains("For"));
<PRINTLN>(hs.isEmpty());
<PRINTLN>(hs.ListItems());
```

---

# ‚úÖ Step‚Äëby‚ÄëStep Explanation

1. **Create HashSet** ‚Üí Capacity `11`.  
2. **addItem()** ‚Üí Adds `"ac"`, `51`, `5`. Duplicate `5` ignored.  
3. **ListItems()** ‚Üí Displays elements (unordered).  
4. **removeItem("ac")** ‚Üí Removes `"ac"`.  
5. **size() / isEmpty()** ‚Üí Shows number of elements and empty status.  
6. **Second HashSet** ‚Üí Adds `"Geek", "For", "Geeks", "A", "B", "Z"`.  
7. **removeItem("B")** ‚Üí Removes `"B"`.  
8. **Contains("For")** ‚Üí Returns `true`.  
9. **Clear()** ‚Üí Removes all elements.  
10. **Final check** ‚Üí `Contains("For")` ‚Üí `false`, `isEmpty()` ‚Üí `true`, `ListItems()` ‚Üí empty.  

---

# üéØ Final Output (Step by Step)

------------------------------------------------------------------------------------
                  HASH SET  EXAMPLES                          
------------------------------------------------------------------------------------
[ac, 51, 5, 5]
true
[51, 5]
2
False
**************
[Geek, For, Geeks, A, B, Z]
[Geek, For, Geeks, A, Z]
5
**************
True
False
True
False
[Geeks, For]

---

# üìò HashSet vs TreeSet

Both **HashSet** and **TreeSet** are part of the **Set collections** family in Dotweb5.0. They store **unique elements** but differ in ordering and performance.

---

## üîë Core Difference

- **HashSet** ‚Üí Stores unique elements in an **unordered collection** (based on hashing).  
- **TreeSet** ‚Üí Stores unique elements in a **sorted collection** (based on tree structure).  

---

## ‚öôÔ∏è Operations Comparison

| Feature / Operation | **HashSet** | **TreeSet** |
|----------------------|-------------|-------------|
| **Data Stored** | Unique elements | Unique elements |
| **Ordering** | No guaranteed order | Sorted (ASC/DESC) |
| **Insertion** | `addItem(element)` | `add(element)` |
| **Access** | `Contains(element)` | `higher(x), lower(x), pollFirst(), pollLast()` |
| **Remove** | `removeItem(element), Clear()` | `remove(element), removeall()` |
| **Traversal** | `ListItems()` | `ASCDisplay(), DESCDisplay()` |
| **Performance** | Faster (O(1) average for add/search/remove) | Slower (O(log n) due to tree balancing) |

---

## üìä Example Flow

### HashSet Example (Dotweb5.0)
```
OJ7Lib.HashSet hs = new OJ7Lib.HashSet(11);
hs.addItem("Geek");
hs.addItem("For");
hs.addItem("Geeks");
hs.addItem("A");
hs.addItem("B");
hs.addItem("Z");

<PRINTLN>(hs.ListItems());        // Unordered output
hs.removeItem("B");
<PRINTLN>(hs.ListItems());        // "B" removed
<PRINTLN>(hs.Contains("For"));    // true
hs.Clear();
<PRINTLN>(hs.isEmpty());          // true
```

### TreeSet Example (Dotweb5.0)
```
OJ7Lib.TreeSet ts = new OJ7Lib.TreeSet("ASC");
ts.add(13);
ts.add(15);
ts.add(12);
ts.add(1);

<PRINTLN>("ASC: " + ts.ASCDisplay());   // [1, 12, 13, 15]
<PRINTLN>("higher= " + ts.higher(13)); // 15
<PRINTLN>("PollFirst= " + ts.pollFirst()); // 1
<PRINTLN>("DESC: " + ts.DESCDisplay());   // [15, 13, 12]
```

---

## üéØ Use Cases

- **HashSet**  
  - Best when you need **fast operations** and don‚Äôt care about order.  
  - Useful for membership checks, duplicate removal, and quick lookups.  

- **TreeSet**  
  - Best when you need **sorted elements**.  
  - Useful for range queries, ordered traversal, and maintaining natural order.  

---

# ‚úÖ Conclusion

- **HashSet** ‚Üí Faster, unordered, ideal for quick lookups.  
- **TreeSet** ‚Üí Slower, ordered, ideal for sorted collections and range-based queries.  
- Both ensure **uniqueness of elements**, but differ in how they organize and access them.  

=========================================================================================


---

# üìò What is a ConcurrentHashMap?

- A **ConcurrentHashMap** is a thread‚Äësafe map that allows multiple threads to access and modify entries concurrently without locking the entire map.  
- It is faster than `Hashtable` because it uses **segment-level locking** or fine-grained concurrency.  
- It does **not allow null keys or null values**.  
- Provides **atomic operations** like `putIfAbsent`, `computeIfAbsent`, `computeIfPresent`, `merge`, etc.  

---

# üìù Definition of J7ConcurrentHashMap (Dotweb5.0)

A **J7ConcurrentHashMap** supports:  
- **put(key, value)** ‚Üí Insert or update a key-value pair.  
- **get(key)** ‚Üí Retrieve value for a given key.  
- **remove(key)** ‚Üí Remove a key-value pair.  
- **ComputeIfAbsent(map, key, value)** ‚Üí Insert value if key is absent.  
- **ComputeIfPresent(map, key, value)** ‚Üí Update value if key is present.  
- **Merge(map, key, value, newValue)** ‚Üí Merge new value with existing one.  
- **Visit(map, key, value)** ‚Üí Traverse or apply an operation across entries.  

---

# ‚ú® Neatly Arranged Dotweb5.0 J7ConcurrentHashMap Example

```
<PRINTLN>("------------------------------------------------------------------------------------");
<PRINTLN>("                 J7Concurrent HashMap  EXAMPLES                          ");
<PRINTLN>("------------------------------------------------------------------------------------");

OJ7Lib.J7ConcurrentHashMap map19 = new OJ7Lib.J7ConcurrentHashMap(16);

// -------------------------------
// put() and get()
// -------------------------------
map19.put("A", 1);
<PRINTLN>(map19.get("A"));

// -------------------------------
// ComputeIfAbsent()
// -------------------------------
map19 = map19.ComputeIfAbsent(map19, "B", "42");
<PRINTLN>(map19.get("B"));

// -------------------------------
// ComputeIfPresent()
// -------------------------------
map19 = map19.ComputeIfPresent(map19, "A", "46");
<PRINTLN>(map19.get("A"));

// -------------------------------
// Merge()
// -------------------------------
map19 = map19.Merge(map19, "B", " ", 3);
<PRINTLN>(map19.get("B"));

// -------------------------------
// Visit()
// -------------------------------
map19 = map19.Visit(map19, "", "");
<PRINTLN>(map19.get("A"));

// -------------------------------
// remove() and put()
// -------------------------------
map19.remove("B");
map19.put("A", null);
map19.put("A", 1);

<PRINTLN>("B=" + map19.get("B"));
<PRINTLN>(map19.get("A"));
```

---

# ‚úÖ Step‚Äëby‚ÄëStep Explanation

1. **put("A",1)** ‚Üí Inserts key `"A"` with value `1`.  
   - `get("A")` ‚Üí `1`.  

2. **ComputeIfAbsent("B","42")** ‚Üí Since `"B"` is absent, inserts `"B" ‚Üí 42`.  
   - `get("B")` ‚Üí `42`.  

3. **ComputeIfPresent("A","46")** ‚Üí Since `"A"` exists, updates value to `46`.  
   - `get("A")` ‚Üí `46`.  

4. **Merge("B"," ",3)** ‚Üí Merges new value `3` with existing `"B"`.  
   - `get("B")` ‚Üí updated value (depending on merge logic, here `3`).  

5. **Visit()** ‚Üí Traverses map entries (implementation-specific).  
   - `get("A")` ‚Üí still `46`.  

6. **remove("B")** ‚Üí Removes key `"B"`.  
   - `get("B")` ‚Üí `null`.  

7. **put("A",null)** ‚Üí Sets `"A"` to `null`.  
   **put("A",1)** ‚Üí Updates `"A"` back to `1`.  
   - `get("A")` ‚Üí `1`.  

---

# üéØ Final Output (Step by Step)

```
------------------------------------------------------------------------------------
                 J7Concurrent HashMap  EXAMPLES                          
------------------------------------------------------------------------------------
1
42
46
3
46
B=null
1
```

---

# üìò ConcurrentHashMap vs Hashtable

Both **ConcurrentHashMap** and **Hashtable** are **Map implementations** that store key‚Äìvalue pairs, but they differ in **thread safety, performance, and usage**.

---

## üîë Core Difference

- **Hashtable** ‚Üí Thread‚Äësafe but uses **synchronized methods**, locking the entire map for every operation.  
- **ConcurrentHashMap** ‚Üí Thread‚Äësafe but uses **fine‚Äëgrained concurrency**, allowing multiple threads to operate simultaneously with better performance.  

---

## ‚öôÔ∏è Operations Comparison

| Feature / Operation | **Hashtable** | **ConcurrentHashMap** |
|----------------------|---------------|------------------------|
| **Thread Safety** | ‚úÖ Yes (synchronized, locks entire map) | ‚úÖ Yes (concurrent, locks segments) |
| **Performance** | Slower (blocking all threads during operations) | Faster (multiple threads can read/write concurrently) |
| **Null Keys/Values** | ‚ùå Not allowed | ‚ùå Not allowed |
| **Atomic Operations** | ‚ùå No | ‚úÖ Yes (`putIfAbsent`, `computeIfAbsent`, `computeIfPresent`, `merge`, etc.) |
| **Iteration** | Enumeration (legacy) | Iterator with fail‚Äësafe behavior |
| **Use Case** | Legacy applications needing synchronization | Modern concurrent applications needing high performance |

---

## üìä Example Flow

### Hashtable Example (Dotweb5.0)
```
OJ7Lib.J7HashTable table = new OJ7Lib.J7HashTable();
table.put("Apple", 10);
table.put("Banana", 20);

<PRINTLN>("Contains key 'Banana'? " + table.containsKey("Banana")); // true
<PRINTLN>("Size: " + table.size());                                // 2
```

### ConcurrentHashMap Example (Dotweb5.0)
```
OJ7Lib.J7ConcurrentHashMap map19 = new OJ7Lib.J7ConcurrentHashMap(16);

map19.put("A", 1);
<PRINTLN>(map19.get("A"));

map19 = map19.ComputeIfAbsent(map19, "B", "42");
<PRINTLN>(map19.get("B"));

map19 = map19.ComputeIfPresent(map19, "A", "46");
<PRINTLN>(map19.get("A"));

map19 = map19.Merge(map19, "B", " ", 3);
<PRINTLN>(map19.get("B"));
```

---

## üéØ Use Cases

- **Hashtable**  
  - Suitable for **legacy code** where synchronization is required.  
  - Simple but less efficient in multi‚Äëthreaded environments.  

- **ConcurrentHashMap**  
  - Suitable for **modern concurrent applications**.  
  - Provides **better scalability and performance**.  
  - Supports **atomic operations** for safe concurrent updates.  

---

# ‚úÖ Conclusion

- **Hashtable** ‚Üí Thread‚Äësafe but slow, locks entire map.  
- **ConcurrentHashMap** ‚Üí Thread‚Äësafe and fast, allows concurrent access with atomic operations.  
- In Dotweb5.0, prefer **ConcurrentHashMap** for multi‚Äëthreaded programs, while **Hashtable** is mainly for backward compatibility.  




===============================================================================================

Note: This  Tutorial  website  is  under construction


